{"version":3,"sources":["../src/symbols.ts","../src/core.ts","../src/serialize.ts","../src/rpc.ts","../src/websocket.ts","../src/batch.ts","../src/messageport.ts","../src/map.ts","../src/index.ts"],"names":["err","hook","RpcStub","RpcPromise","RpcSession","RpcTarget","newWebSocketRpcSession","newHttpBatchRpcSession","newMessagePortRpcSession"],"mappings":"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","file":"index.cjs","sourcesContent":["// Copyright (c) 2025 Cloudflare, Inc.\n// Licensed under the MIT license found in the LICENSE.txt file or at:\n//     https://opensource.org/license/mit\n\nexport let WORKERS_MODULE_SYMBOL = Symbol(\"workers-module\");\n","// Copyright (c) 2025 Cloudflare, Inc.\n// Licensed under the MIT license found in the LICENSE.txt file or at:\n//     https://opensource.org/license/mit\n\nimport type { RpcTargetBranded, __RPC_TARGET_BRAND } from \"./types.js\";\nimport { WORKERS_MODULE_SYMBOL } from \"./symbols.js\"\n\n// Polyfill Symbol.dispose for browsers that don't support it yet\nif (!Symbol.dispose) {\n  (Symbol as any).dispose = Symbol.for('dispose');\n}\nif (!Symbol.asyncDispose) {\n  (Symbol as any).asyncDispose = Symbol.for('asyncDispose');\n}\n\n// Polyfill Promise.withResolvers() for old Safari versions (ugh), Hermes (React Native), and\n// maybe others.\nif (!Promise.withResolvers) {\n  Promise.withResolvers = function<T>(): PromiseWithResolvers<T> {\n    let resolve: (value: T | PromiseLike<T>) => void;\n    let reject: (reason?: any) => void;\n    const promise = new Promise<T>((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    return { promise, resolve: resolve!, reject: reject! };\n  };\n}\n\nlet workersModule: any = (globalThis as any)[WORKERS_MODULE_SYMBOL];\n\nexport interface RpcTarget {\n  [__RPC_TARGET_BRAND]: never;\n};\n\nexport let RpcTarget = workersModule ? workersModule.RpcTarget : class {};\n\nexport type PropertyPath = (string | number)[];\n\ntype TypeForRpc = \"unsupported\" | \"primitive\" | \"object\" | \"function\" | \"array\" | \"date\" |\n    \"bigint\" | \"bytes\" | \"stub\" | \"rpc-promise\" | \"rpc-target\" | \"rpc-thenable\" | \"error\" |\n    \"undefined\";\n\nconst AsyncFunction = (async function () {}).constructor;\n\nexport function typeForRpc(value: unknown): TypeForRpc {\n  switch (typeof value) {\n    case \"boolean\":\n    case \"number\":\n    case \"string\":\n      return \"primitive\";\n\n    case \"undefined\":\n      return \"undefined\";\n\n    case \"object\":\n    case \"function\":\n      // Test by prototype, below.\n      break;\n\n    case \"bigint\":\n      return \"bigint\";\n\n    default:\n      return \"unsupported\";\n  }\n\n  // Ugh JavaScript, why is `typeof null` equal to \"object\" but null isn't otherwise anything like\n  // an object?\n  if (value === null) {\n    return \"primitive\";\n  }\n\n  // Aside from RpcTarget, we generally don't support serializing *subclasses* of serializable\n  // types, so we switch on the exact prototype rather than use `instanceof` here.\n  let prototype = Object.getPrototypeOf(value);\n  switch (prototype) {\n    case Object.prototype:\n      return \"object\";\n\n    case Function.prototype:\n    case AsyncFunction.prototype:\n      return \"function\";\n\n    case Array.prototype:\n      return \"array\";\n\n    case Date.prototype:\n      return \"date\";\n\n    case Uint8Array.prototype:\n      return \"bytes\";\n\n    // TODO: All other structured clone types.\n\n    case RpcStub.prototype:\n      return \"stub\";\n\n    case RpcPromise.prototype:\n      return \"rpc-promise\";\n\n    // TODO: Promise<T> or thenable\n\n    default:\n      if (workersModule) {\n        // TODO: We also need to match `RpcPromise` and `RpcProperty`, but they currently aren't\n        //   exported by cloudflare:workers.\n        if (prototype == workersModule.RpcStub.prototype ||\n            value instanceof workersModule.ServiceStub) {\n          return \"rpc-target\";\n        } else if (prototype == workersModule.RpcPromise.prototype ||\n                   prototype == workersModule.RpcProperty.prototype) {\n          // Like rpc-target, but should be wrapped in RpcPromise, so that it can be pull()ed,\n          // which will await the thenable.\n          return \"rpc-thenable\";\n        }\n      }\n\n      if (value instanceof RpcTarget) {\n        return \"rpc-target\";\n      }\n\n      if (value instanceof Error) {\n        return \"error\";\n      }\n\n      return \"unsupported\";\n  }\n}\n\nfunction mapNotLoaded(): never {\n  throw new Error(\"RPC map() implementation was not loaded.\");\n}\n\n// map() is implemented in `map.ts`. We can't import it here because it would create an import\n// cycle, so instead we define two hook functions that map.ts will overwrite when it is imported.\nexport let mapImpl: MapImpl = { applyMap: mapNotLoaded, sendMap: mapNotLoaded };\n\ntype MapImpl = {\n  // Applies a map function to an input value (usually an array).\n  applyMap(input: unknown, parent: object | undefined, owner: RpcPayload | null,\n           captures: StubHook[], instructions: unknown[])\n          : StubHook;\n\n  // Implements the .map() method of RpcStub.\n  sendMap(hook: StubHook, path: PropertyPath, func: (value: RpcPromise) => unknown)\n         : RpcPromise;\n}\n\n// Inner interface backing an RpcStub or RpcPromise.\n//\n// A hook may eventually resolve to a \"payload\".\n//\n// Declared as `abstract class` to allow `instanceof StubHook`, used by `RpcStub` constructor.\n//\n// This is conceptually similar to the Cap'n Proto C++ class `ClientHook`.\nexport abstract class StubHook {\n  // Call a function at the given property path with the given arguments. Returns a hook for the\n  // promise for the result.\n  abstract call(path: PropertyPath, args: RpcPayload): StubHook;\n\n  // Apply a map operation.\n  //\n  // `captures` is a list of external stubs which are used as part of the mapper function.\n  // NOTE: The callee takes ownership of `captures`.\n  //\n  // `instructions` is a JSON-serializable value describing the mapper function as a series of\n  // steps. Each step is an expression to evaluate, in the usual RPC expression format. The last\n  // instruction is the return value.\n  //\n  // Each instruction can refer to the results of any of the instructions before it, as well as to\n  // the captures, as if they were imports on the import table. In particular:\n  // * The value 0 is the input to the mapper function (e.g. one element of the array being mapped).\n  // * Positive values are 1-based indexes into the instruction table, representing the results of\n  //   previous instructions.\n  // * Negative values are -1-based indexes into the capture list.\n  abstract map(path: PropertyPath, captures: StubHook[], instructions: unknown[]): StubHook;\n\n  // Read the property at the given path. Returns a StubHook representing a promise for that\n  // property. This behaves very similarly to call(), except that no actual function is invoked\n  // on the remote end, the property is simply returned. (Well, if the property has a getter, then\n  // that will be invoked...)\n  //\n  // (In the case that this stub is a promise with a resolution payload, get() implies cloning\n  // a branch of the payload, making a deep copy of any pass-by-value content.)\n  abstract get(path: PropertyPath): StubHook;\n\n  // Create a clone of this StubHook, which can be disposed independently.\n  //\n  // The returned hook is NOT considered a promise, so will not resolve to a payload (you can use\n  // `get([])` to get a promise for a cloned payload).\n  abstract dup(): StubHook;\n\n  // Requests resolution of a StubHook that represents a promise, and eventually produces the\n  // payload.\n  //\n  // pull() should not be called on capabilities that aren't promises. It may never resolve or it\n  // may throw an exception.\n  //\n  // If pull() is never called (on a remote promise), the RPC system will not transmit the\n  // resolution at all. This allows a promise to be used strictly for pipelining.\n  //\n  // If the payload is already available, pull() returns it immediately, instead of returning a\n  // promise. This allows the caller to skip the microtask queue which is sometimes necessary to\n  // maintain e-order guarantees.\n  //\n  // The returned RpcPayload is the same one backing the StubHook itself. If the caller delivers\n  // or disposes the payload directly, then it should not call dispose() on the hook. If the caller\n  // does not intend to consume the StubHook, the caller must take responsibility for cloning the\n  // payload.\n  //\n  // You can call pull() multiple times, but it will return the same RpcPayload every time, and\n  // that payload should only be disposed once.\n  //\n  // If pull() returns a promise which rejects, the StubHook does not need to be disposed.\n  abstract pull(): RpcPayload | Promise<RpcPayload>;\n\n  // Called to prevent this stub from generating unhandled rejection events if it throws without\n  // having been pulled. Without this, if a client \"push\"es a call that immediately throws before\n  // the client manages to \"pull\" it or use it in a pipeline, this may be treated by the system as\n  // an unhandled rejection. Unfortunately, this unhandled rejection would be reported in the\n  // callee rather than the caller, possibly causing the callee to crash or log spurious errors,\n  // even though it's really up to the caller to deal with the exception!\n  abstract ignoreUnhandledRejections(): void;\n\n  // Attempts to cancel any outstanding promise backing this hook, and disposes the payload that\n  // pull() would return (if any). If a pull() promise is outstanding, it may still resolve (with\n  // a disposed payload) or it may reject. It's safe to call dispose() multiple times.\n  abstract dispose(): void;\n\n  abstract onBroken(callback: (error: any) => void): void;\n}\n\nexport class ErrorStubHook extends StubHook {\n  constructor(private error: any) { super(); }\n\n  call(path: PropertyPath, args: RpcPayload): StubHook { return this; }\n  map(path: PropertyPath, captures: StubHook[], instructions: unknown[]): StubHook { return this; }\n  get(path: PropertyPath): StubHook { return this; }\n  dup(): StubHook { return this; }\n  pull(): RpcPayload | Promise<RpcPayload> { return Promise.reject(this.error); }\n  ignoreUnhandledRejections(): void {}\n  dispose(): void {}\n  onBroken(callback: (error: any) => void): void {\n    try {\n      callback(this.error);\n    } catch (err) {\n      // Don't throw back into the RPC system. Treat this as an unhandled rejection.\n      Promise.resolve(err);\n    }\n  }\n};\n\nconst DISPOSED_HOOK: StubHook = new ErrorStubHook(\n    new Error(\"Attempted to use RPC stub after it has been disposed.\"));\n\n// A call interceptor can be used to intercept all RPC stub invocations within some synchronous\n// scope. This is used to implement record/replay\ntype CallInterceptor = (hook: StubHook, path: PropertyPath, params: RpcPayload) => StubHook;\nlet doCall: CallInterceptor = (hook: StubHook, path: PropertyPath, params: RpcPayload) => {\n  return hook.call(path, params);\n}\n\nexport function withCallInterceptor<T>(interceptor: CallInterceptor, callback: () => T): T {\n  let oldValue = doCall;\n  doCall = interceptor;\n  try {\n    return callback();\n  } finally {\n    doCall = oldValue;\n  }\n}\n\n// Private symbol which may be used to unwrap the real stub through the Proxy.\nlet RAW_STUB = Symbol(\"realStub\");\n\nexport interface RpcStub extends Disposable {\n  // Declare magic `RAW_STUB` key that unwraps the proxy.\n  [RAW_STUB]: this;\n}\n\nconst PROXY_HANDLERS: ProxyHandler<{raw: RpcStub}> = {\n  apply(target: {raw: RpcStub}, thisArg: any, argumentsList: any[]) {\n    let stub = target.raw;\n    return new RpcPromise(doCall(stub.hook,\n        stub.pathIfPromise || [], RpcPayload.fromAppParams(argumentsList)), []);\n  },\n\n  get(target: {raw: RpcStub}, prop: string | symbol, receiver: any) {\n    let stub = target.raw;\n    if (prop === RAW_STUB) {\n      return stub;\n    } else if (prop in RpcPromise.prototype) {\n      // Any method or property declared on RpcPromise (including inherited from RpcStub or\n      // Object) should pass through to the target object, as trying to turn these into RPCs will\n      // likely be problematic.\n      //\n      // Note we don't just check `prop in target` because we intentionally want to hide the\n      // properties `hook` and `path`.\n      return (<any>stub)[prop];\n    } else if (typeof prop === \"string\") {\n      // Return promise for property.\n      return new RpcPromise(stub.hook,\n          stub.pathIfPromise ? [...stub.pathIfPromise, prop] : [prop]);\n    } else if (prop === Symbol.dispose &&\n          (!stub.pathIfPromise || stub.pathIfPromise.length == 0)) {\n      // We only advertise Symbol.dispose on stubs and root promises, not properties.\n      return () => {\n        stub.hook.dispose();\n        stub.hook = DISPOSED_HOOK;\n      };\n    } else {\n      return undefined;\n    }\n  },\n\n  has(target: {raw: RpcStub}, prop: string | symbol) {\n    let stub = target.raw;\n    if (prop === RAW_STUB) {\n      return true;\n    } else if (prop in RpcPromise.prototype) {\n      return prop in stub;\n    } else if (typeof prop === \"string\") {\n      return true;\n    } else if (prop === Symbol.dispose &&\n          (!stub.pathIfPromise || stub.pathIfPromise.length == 0)) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  construct(target: {raw: RpcStub}, args: any) {\n    throw new Error(\"An RPC stub cannot be used as a constructor.\");\n  },\n\n  defineProperty(target: {raw: RpcStub}, property: string | symbol, attributes: PropertyDescriptor)\n      : boolean {\n    throw new Error(\"Can't define properties on RPC stubs.\");\n  },\n\n  deleteProperty(target: {raw: RpcStub}, p: string | symbol): boolean {\n    throw new Error(\"Can't delete properties on RPC stubs.\");\n  },\n\n  getOwnPropertyDescriptor(target: {raw: RpcStub}, p: string | symbol): PropertyDescriptor | undefined {\n    // Treat all properties as prototype properties. That's probably fine?\n    return undefined;\n  },\n\n  getPrototypeOf(target: {raw: RpcStub}): object | null {\n    return Object.getPrototypeOf(target.raw);\n  },\n\n  isExtensible(target: {raw: RpcStub}): boolean {\n    return false;\n  },\n\n  ownKeys(target: {raw: RpcStub}): ArrayLike<string | symbol> {\n    return [];\n  },\n\n  preventExtensions(target: {raw: RpcStub}): boolean {\n    // Extensions are not possible anyway.\n    return true;\n  },\n\n  set(target: {raw: RpcStub}, p: string | symbol, newValue: any, receiver: any): boolean {\n    throw new Error(\"Can't assign properties on RPC stubs.\");\n  },\n\n  setPrototypeOf(target: {raw: RpcStub}, v: object | null): boolean {\n    throw new Error(\"Can't override prototype of RPC stubs.\");\n  },\n};\n\n// Implementation of RpcStub.\n//\n// Note that the in the public API, we override the type of RpcStub to reflect the interface\n// exposed by the proxy. That happens in index.ts. But for internal purposes, it's easier to just\n// omit the type parameter.\nexport class RpcStub extends RpcTarget {\n  // Although `hook` and `path` are declared `public` here, they are effectively hidden by the\n  // proxy.\n  constructor(hook: StubHook, pathIfPromise?: PropertyPath) {\n    super();\n\n    if (!(hook instanceof StubHook)) {\n      // Application invoked the constructor to explicitly construct a stub backed by some value\n      // (usually an RpcTarget). (Note we override the types as seen by the app, which is why\n      // the app can pass something that isn't a StubHook -- within the implementation, though,\n      // we always pass StubHook.)\n      let value = <any>hook;\n      if (value instanceof RpcTarget || value instanceof Function) {\n        hook = TargetStubHook.create(value, undefined);\n      } else {\n        // We adopt the value with \"return\" semantics since we want to take ownership of any stubs\n        // within.\n        hook = new PayloadStubHook(RpcPayload.fromAppReturn(value));\n      }\n\n      // Don't let app set this.\n      if (pathIfPromise) {\n        throw new TypeError(\"RpcStub constructor expected one argument, received two.\");\n      }\n    }\n\n    this.hook = hook;\n    this.pathIfPromise = pathIfPromise;\n\n    // Proxy has an unfortunate rule that it will only be considered callable if the underlying\n    // `target` is callable, i.e. a function. So our target *must* be callable. So we use a\n    // dummy function.\n    let func: any = () => {};\n    func.raw = this;\n    return new Proxy(func, PROXY_HANDLERS);\n  }\n\n  public hook: StubHook;\n  public pathIfPromise?: PropertyPath;\n\n  dup(): RpcStub {\n    // Unfortunately the method will be invoked with `this` being the Proxy, not the `RpcPromise`\n    // itself, so we have to unwrap it.\n\n    // Note dup() intentionally resets the path to empty and turns the result into a stub.\n    // TODO: Maybe it should actually return the same type? But I think that's not what it does\n    //   in Workers RPC today? (Need to check.) Alternatively, should there be an optional\n    //   parameter to specify promise vs. stub?\n    let target = this[RAW_STUB];\n    if (target.pathIfPromise) {\n      return new RpcStub(target.hook.get(target.pathIfPromise));\n    } else {\n      return new RpcStub(target.hook.dup());\n    }\n  }\n\n  onRpcBroken(callback: (error: any) => void) {\n    this[RAW_STUB].hook.onBroken(callback);\n  }\n\n  map(func: (value: RpcPromise) => unknown): RpcPromise {\n    let {hook, pathIfPromise} = this[RAW_STUB];\n    return mapImpl.sendMap(hook, pathIfPromise || [], func);\n  }\n\n  toString() {\n    return \"[object RpcStub]\";\n  }\n}\n\nexport class RpcPromise extends RpcStub {\n  // TODO: Support passing target value or promise to constructor.\n  constructor(hook: StubHook, pathIfPromise: PropertyPath) {\n    super(hook, pathIfPromise);\n  }\n\n  then(onfulfilled?: ((value: unknown) => unknown) | undefined | null,\n       onrejected?: ((reason: any) => unknown) | undefined | null)\n       : Promise<unknown> {\n    return pullPromise(this).then(...arguments);\n  }\n\n  catch(onrejected?: ((reason: any) => unknown) | undefined | null): Promise<unknown> {\n    return pullPromise(this).catch(...arguments);\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<unknown> {\n    return pullPromise(this).finally(...arguments);\n  }\n\n  toString() {\n    return \"[object RpcPromise]\";\n  }\n}\n\n// Given a stub (still wrapped in a Proxy), extract the underlying `StubHook`.\n//\n// The caller takes ownership, meaning it's expected that the original stub will never be disposed\n// itself, but the caller is responsible for calling `dispose()` on the returned hook.\n//\n// However, if the stub points to a property of some other stub or promise, then no ownership is\n// \"transferred\" because properties do not actually have disposers. However, the returned hook is\n// a new hook that aliases that property, but does actually need to be disposed.\n//\n// The result is a promise (i.e. can be pull()ed) if and only if the input is a promise.\nexport function unwrapStubTakingOwnership(stub: RpcStub): StubHook {\n  let {hook, pathIfPromise} = stub[RAW_STUB];\n\n  if (pathIfPromise && pathIfPromise.length > 0) {\n    return hook.get(pathIfPromise);\n  } else {\n    return hook;\n  }\n}\n\n// Given a stub (still wrapped in a Proxy), extract the underlying `StubHook`, and duplicate it,\n// returning the duplicate.\n//\n// The caller is responsible for disposing the returned hook, but the original stub also still\n// needs to be disposed by its owner (unless it is a property, which never needs disposal).\n//\n// The result is a promise (i.e. can be pull()ed) if and only if the input is a promise. Note that\n// this differs from the semantics of the actual `dup()` method.\nexport function unwrapStubAndDup(stub: RpcStub): StubHook {\n  let {hook, pathIfPromise} = stub[RAW_STUB];\n\n  if (pathIfPromise) {\n    return hook.get(pathIfPromise);\n  } else {\n    return hook.dup();\n  }\n}\n\n// Unwrap a stub returning the underlying `StubHook`, returning `undefined` if it is a property\n// stub.\n//\n// This function is agnostic to ownership transfer. Exactly one of `stub` or the return `hook` must\n// eventually be disposed (unless `undefined` is returned, in which case neither need to be\n// disposed, as properties are not normally disposable).\nexport function unwrapStubNoProperties(stub: RpcStub): StubHook | undefined {\n  let {hook, pathIfPromise} = stub[RAW_STUB];\n\n  if (pathIfPromise && pathIfPromise.length > 0) {\n    return undefined;\n  }\n\n  return hook;\n}\n\n// Unwrap a stub returning the underlying `StubHook`. If it's a property, return the `StubHook`\n// representing the stub or promise of which is is a property.\n//\n// This function is agnostic to ownership transfer. Exactly one of `stub` or the return `hook` must\n// eventually be disposed.\nexport function unwrapStubOrParent(stub: RpcStub): StubHook {\n  return stub[RAW_STUB].hook;\n}\n\n// Given a stub (still wrapped in a Proxy), extract the `hook` and `pathIfPromise` properties.\n//\n// This function is agnostic to ownership transfer. Exactly one of `stub` or the return `hook` must\n// eventually be disposed.\nexport function unwrapStubAndPath(stub: RpcStub): {hook: StubHook, pathIfPromise?: PropertyPath} {\n  return stub[RAW_STUB];\n}\n\n// Given a promise stub (still wrapped in a Proxy), pull the remote promise and deliver the\n// payload. This is a helper used to implement the then/catch/finally methods of RpcPromise.\nasync function pullPromise(promise: RpcPromise): Promise<unknown> {\n  let {hook, pathIfPromise} = promise[RAW_STUB];\n  if (pathIfPromise!.length > 0) {\n    // If this isn't the root promise, we have to clone it and pull the clone. This is a little\n    // weird in terms of disposal: There's no way for the app to dispose/cancel the promise while\n    // waiting because it never actually got a direct disposable reference. It has to dispose\n    // the result.\n    hook = hook.get(pathIfPromise!);\n  }\n  let payload = await hook.pull();\n  return payload.deliverResolve();\n}\n\n// =======================================================================================\n// RpcPayload\n\nexport type LocatedPromise = {parent: object, property: string | number, promise: RpcPromise};\n\n// Represents the params to an RPC call, or the resolution of an RPC promise, as it passes\n// through the system.\n//\n// `RpcPayload` is a linear type -- it is passed to or returned from a call, ownership is being\n// transferred. The payload in turn owns all the stubs within it. Disposing the payload disposes\n// the stubs.\n//\n// Hypothetically, when an `RpcPayload` is first constructed from a message structure passed from\n// the app, it ought to be deep-copied, for a few reasons:\n// - To ensure subsequent modifications of the data structure by the app aren't reflected in the\n//   already-sent message.\n// - To find all stubs in the message tree, to take ownership of them.\n// - To find all RpcTargets in the message tree, to wrap them in stubs.\n//\n// However, most payloads are immediately serialized to send across the wire. Said serialization\n// *also* has to make a deep copy, and takes ownership of all stubs found within. In the case that\n// the payload is immediately serialized, then making a deep copy first is wasteful.\n//\n// So, as an optimization, RpcPayload does not necessarily make a copy right away. Instead, it\n// keeps track of whether it's still pointing at the message structure received directly from the\n// app. In that case, the serializer can operate on the original structure directly, making it\n// more efficient.\n//\n// On the receiving end, when an RpcPayload is deserialized from the wire, the payload can safely\n// be delivered directly to the app without a copy. However, if the app makes a loopback call to\n// itself, the payload may never cross the wire. In this case, a deep copy must be made before\n// delivering the final message to the app. There are really two reasons for this copy:\n// - We obviously don't want the caller and callee sharing in-memory mutable data structures, as\n//   this would lead to vasty different behavior than what you'd see when doing RPC across a\n//   network connection.\n// - Before delivering the message to the application, all promises embedded in the message must\n//   be resolved. This is what makes pipelining possible: the sender of a message can place\n//   `RpcPromise`s in it that refer back to values in the recipient's process. These will be filled\n//   in just before delivering the message to the recipient, so that there's no need to transmit\n//   these values back and forth across the wire. It would be unreasonable to expect the\n//   application itself to check the message for promises and resolve them all, so instead the\n//   system automatically resolves all promises upfront, replacing them with their resolutions.\n//   This modifies the payload in-place -- but this of course requires that the payload is\n//   operating on a copy of the message, not the original provided from the sending app.\n//\n// For both the purposes of disposal and substituting promises with their resolutions, it is\n// necessary at some point to make a list of all the stubs (including promise stubs) present in\n// the message. Again, `RpcPayload` tries to minimize the number of times that the whole message\n// needs to be walked, so it implements the following policy:\n// * When constructing a payload from an app-provided message object, the message is not walked\n//   upfront. We do not know yet what stubs it contains.\n// * When deserializing a payload from the wire, we build a list of stubs as part of the\n//   deserialization process.\n// * If we need to deep-copy an app-provided message, we make a list of stubs then.\n// * Hence, we have a list of stubs if and only if the message structure was NOT provided directly\n//   by the application.\n// * If an app-provided payload is serialized, the serializer finds the stubs. (It also typically\n//   takes ownership of the stubs, effectively consuming the payload, so there's no need to build\n//   a list of the stubs.)\n// * If an app-provided payload is disposed, then we have to walk the message at that time to\n//   dispose all stubs within. But, note that when a payload is serialized -- with the serializer\n//   taking ownership of stubs -- then the payload will NOT be disposed explicitly, so this step\n//   will not be needed.\nexport class RpcPayload {\n  // Create a payload from a value passed as params to an RPC from the app.\n  //\n  // The payload does NOT take ownership of any stubs in `value`, and but promises not to modify\n  // `value`. If the payload is delivered locally, `value` will be deep-copied first, so as not\n  // to have the sender and recipient end up sharing the same mutable object. `value` will not be\n  // touched again after the call returns synchronously (returns a promise) -- by that point,\n  // the value has either been copied or serialized to the wire.\n  public static fromAppParams(value: unknown): RpcPayload {\n    return new RpcPayload(value, \"params\");\n  }\n\n  // Create a payload from a value return from an RPC implementation by the app.\n  //\n  // Unlike fromAppParams(), in this case the payload takes ownership of all stubs in `value`, and\n  // may hold onto `value` for an arbitrarily long time (e.g. to serve pipelined requests). It\n  // will still avoid modifying `value` and will make a deep copy if it is delivered locally.\n  public static fromAppReturn(value: unknown): RpcPayload {\n    return new RpcPayload(value, \"return\");\n  }\n\n  // Combine an array of payloads into a single payload whose value is an array. Ownership of all\n  // stubs is transferred from the inputs to the outputs, hence if the output is disposed, the\n  // inputs should not be. (In case of exception, nothing is disposed, though.)\n  public static fromArray(array: RpcPayload[]): RpcPayload {\n    let stubs: RpcStub[] = [];\n    let promises: LocatedPromise[] = [];\n\n    let resultArray: unknown[] = [];\n\n    for (let payload of array) {\n      payload.ensureDeepCopied();\n      for (let stub of payload.stubs!) {\n        stubs.push(stub);\n      }\n      for (let promise of payload.promises!) {\n        if (promise.parent === payload) {\n          // This promise is the root of the source payload. We need to reparent it to its proper\n          // location in the result array.\n          promise = {\n            parent: resultArray,\n            property: resultArray.length,\n            promise: promise.promise\n          };\n        }\n        promises.push(promise);\n      }\n      resultArray.push(payload.value);\n    }\n\n    return new RpcPayload(resultArray, \"owned\", stubs, promises);\n  }\n\n  // Create a payload from a value parsed off the wire using Evaluator.evaluate().\n  //\n  // A payload is constructed with a null value and the given stubs and promises arrays. The value\n  // is expected to be filled in by the evaluator, and the stubs and promises arrays are expected\n  // to be extended with stubs found during parsing. (This weird usage model is necessary so that\n  // if the root value turns out to be a promise, its `parent` in `promises` can be the payload\n  // object itself.)\n  //\n  // When done, the payload takes ownership of the final value and all the stubs within. It may\n  // modify the value in preparation for delivery, and may deliver the value directly to the app\n  // without copying.\n  public static forEvaluate(stubs: RpcStub[], promises: LocatedPromise[]) {\n    return new RpcPayload(null, \"owned\", stubs, promises);\n  }\n\n  // Deep-copy the given value, including dup()ing all stubs.\n  //\n  // If `value` is a function, it should be bound to `oldParent` as its `this`.\n  //\n  // If deep-copying from a branch of some other RpcPayload, it must be provided, to make sure\n  // RpcTargets found within don't get duplicate stubs.\n  public static deepCopyFrom(\n      value: unknown, oldParent: object | undefined, owner: RpcPayload | null): RpcPayload {\n    let result = new RpcPayload(null, \"owned\", [], []);\n    result.value = result.deepCopy(value, oldParent, \"value\", result, /*dupStubs=*/true, owner);\n    return result;\n  }\n\n  // Private constructor; use factory functions above to construct.\n  private constructor(\n    // The payload value.\n    public value: unknown,\n\n    // What is the provenance of `value`?\n    // \"params\": It came from the app, in params to a call. We must dupe any stubs within.\n    // \"return\": It came from the app, returned from a call. We take ownership of all stubs within.\n    // \"owned\": This value belongs fully to us, either because it was deserialized from the wire\n    //   or because we deep-copied a value from the app.\n    private source: \"params\" | \"return\" | \"owned\",\n\n    // `stubs` and `promises` are filled in only if `value` belongs to us (`source` is \"owned\") and\n    // so can safely be delivered to the app. If `value` came from then app in the first place,\n    // then it cannot be delivered back to the app nor modified by us without first deep-copying\n    // it. `stubs` and `promises` will be computed as part of the deep-copy.\n\n    // All non-promise stubs found in `value`. Provided so that they can easily be disposed.\n    private stubs?: RpcStub[],\n\n    // All promises found in `value`. The locations of each promise are provided to allow\n    // substitutions later.\n    private promises?: LocatedPromise[]\n  ) {}\n\n  // For `source === \"return\"` payloads only, this tracks any StubHooks created around RpcTargets\n  // found in the payload at the time that it is serialized (or deep-copied) for return, so that we\n  // can make sure they are not disposed before the pipeline ends.\n  //\n  // This is initialized on first use.\n  private rpcTargets?: Map<RpcTarget | Function, StubHook>;\n\n  // Get the StubHook representing the given RpcTarget found inside this payload.\n  public getHookForRpcTarget(target: RpcTarget | Function, parent: object | undefined,\n                             dupStubs: boolean = true): StubHook {\n    if (this.source === \"params\") {\n      if (dupStubs) {\n        // We aren't supposed to take ownership of stubs appearing in params -- we're supposed to\n        // dupe them. But an RpcTarget isn't a stub. If we create a stub around it, the stub takes\n        // ownership.\n        //\n        // Usually, people passing raw RpcTargets into functions actually want the call to take\n        // ownership -- that is, they want to have the disposer called later.\n        //\n        // But, if the RpcTarget happens to implement a `dup()` method, we will go ahead and call\n        // that method, and wrap whatever it returns instead. This method wouldn't actually be\n        // available over RPC anyway (since calling `dup()` on the client-side stub just dupes the\n        // stub), so if an `RpcTarget` implements this, it must intend for us to use it.\n        //\n        // This is particularly important for the case of workerd-native RpcStubs, that is, stubs\n        // from the built-in RPC system, rather than the pure-JS implementation of Cap'n Web.\n        // We treat those stubs as RpcTargets. But, we do need to dup() them, just like we would\n        // our own stubs.\n\n        let dupable = target as any;\n        if (typeof dupable.dup === \"function\") {\n          target = dupable.dup();\n        }\n      }\n\n      return TargetStubHook.create(target, parent);\n    } else if (this.source === \"return\") {\n      // If dupStubs is true, we want to both make sure the map contains the stub, and also return\n      // a dup of that stub.\n      //\n      // If dupStubs is false, then we are being called as part of ensureDeepCopy(), i.e. replacing\n      // ourselves with a deep copy. In this case we actually want the copy to end up owning all\n      // the hooks, and the map to be left empty. So what we do in this case is:\n      // * If the target is not in the map, we just create it, but don't populate the map.\n      // * If the target *is* in the map, we *remove* the hook from the map, and return it.\n\n      let hook = this.rpcTargets?.get(target);\n      if (hook) {\n        if (dupStubs) {\n          return hook.dup();\n        } else {\n          this.rpcTargets?.delete(target);\n          return hook;\n        }\n      } else {\n        hook = TargetStubHook.create(target, parent);\n        if (dupStubs) {\n          if (!this.rpcTargets) {\n            this.rpcTargets = new Map;\n          }\n          this.rpcTargets.set(target, hook);\n          return hook.dup();\n        } else {\n          return hook;\n        }\n      }\n    } else {\n      throw new Error(\"owned payload shouldn't contain raw RpcTargets\");\n    }\n  }\n\n  private deepCopy(\n      value: unknown, oldParent: object | undefined, property: string | number, parent: object,\n      dupStubs: boolean, owner: RpcPayload | null): unknown {\n    let kind = typeForRpc(value);\n    switch (kind) {\n      case \"unsupported\":\n        // This will throw later on when someone tries to do something with it.\n        return value;\n\n      case \"primitive\":\n      case \"bigint\":\n      case \"date\":\n      case \"bytes\":\n      case \"error\":\n      case \"undefined\":\n        // immutable, no need to copy\n        // TODO: Should errors be copied if they have own properties?\n        return value;\n\n      case \"array\": {\n        // We have to construct the new array first, then fill it in, so we can pass it as the\n        // parent.\n        let array = <Array<unknown>>value;\n        let len = array.length;\n        let result = new Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = this.deepCopy(array[i], array, i, result, dupStubs, owner);\n        }\n        return result;\n      }\n\n      case \"object\": {\n        // Plain object. Unfortunately there's no way to pre-allocate the right shape.\n        let result: Record<string, unknown> = {};\n        let object = <Record<string, unknown>>value;\n        for (let i in object) {\n          result[i] = this.deepCopy(object[i], object, i, result, dupStubs, owner);\n        }\n        return result;\n      }\n\n      case \"stub\":\n      case \"rpc-promise\": {\n        let stub = <RpcStub>value;\n        let hook: StubHook;\n        if (dupStubs) {\n          hook = unwrapStubAndDup(stub);\n        } else {\n          hook = unwrapStubTakingOwnership(stub);\n        }\n        if (stub instanceof RpcPromise) {\n          let promise = new RpcPromise(hook, []);\n          this.promises!.push({parent, property, promise});\n          return promise;\n        } else {\n          let newStub = new RpcStub(hook);\n          this.stubs!.push(newStub);\n          return newStub;\n        }\n      }\n\n      case \"function\":\n      case \"rpc-target\": {\n        let target = <RpcTarget | Function>value;\n        let stub: RpcStub;\n        if (owner) {\n          stub = new RpcStub(owner.getHookForRpcTarget(target, oldParent, dupStubs));\n        } else {\n          stub = new RpcStub(TargetStubHook.create(target, oldParent));\n        }\n        this.stubs!.push(stub);\n        return stub;\n      }\n\n      case \"rpc-thenable\": {\n        let target = <RpcTarget>value;\n        let promise: RpcPromise;\n        if (owner) {\n          promise = new RpcPromise(owner.getHookForRpcTarget(target, oldParent, dupStubs), []);\n        } else {\n          promise = new RpcPromise(TargetStubHook.create(target, oldParent), []);\n        }\n        this.promises!.push({parent, property, promise});\n        return promise;\n      }\n\n      default:\n        kind satisfies never;\n        throw new Error(\"unreachable\");\n    }\n  }\n\n  // Ensures that if the value originally came from an unowned source, we have replaced it with a\n  // deep copy.\n  public ensureDeepCopied() {\n    if (this.source !== \"owned\") {\n      // If we came from call params, we need to dupe any stubs. Otherwise (we came from a return),\n      // we take ownership of all stubs.\n      let dupStubs = this.source === \"params\";\n\n      this.stubs = [];\n      this.promises = [];\n\n      // Deep-copy the value.\n      try {\n        this.value = this.deepCopy(this.value, undefined, \"value\", this, dupStubs, this);\n      } catch (err) {\n        // Roll back the change.\n        this.stubs = undefined;\n        this.promises = undefined;\n        throw err;\n      }\n\n      // We now own the value.\n      this.source = \"owned\";\n\n      // `rpcTargets` should have been left empty. We can throw it out.\n      if (this.rpcTargets && this.rpcTargets.size > 0) {\n        throw new Error(\"Not all rpcTargets were accounted for in deep-copy?\");\n      }\n      this.rpcTargets = undefined;\n    }\n  }\n\n  // Resolve all promises in this payload and then assign the final value into `parent[property]`.\n  private deliverTo(parent: object, property: string | number, promises: Promise<any>[]): void {\n    this.ensureDeepCopied();\n\n    if (this.value instanceof RpcPromise) {\n      RpcPayload.deliverRpcPromiseTo(this.value, parent, property, promises);\n    } else {\n      (<any>parent)[property] = this.value;\n\n      for (let record of this.promises!) {\n        // Note that because we already did ensureDeepCopied(), replacing each promise with its\n        // resolution does not interfere with disposal later on -- disposal will be based on the\n        // `promises` list, so will still properly dispose each promise, which in turn disposes\n        // the promise's eventual payload.\n        RpcPayload.deliverRpcPromiseTo(record.promise, record.parent, record.property, promises);\n      }\n    }\n  }\n\n  private static deliverRpcPromiseTo(\n      promise: RpcPromise, parent: object, property: string | number,\n      promises: Promise<unknown>[]) {\n    // deepCopy() should have replaced any property stubs with normal promise stubs.\n    let hook = unwrapStubNoProperties(promise);\n    if (!hook) {\n      throw new Error(\"property promises should have been resolved earlier\");\n    }\n\n    let inner = hook.pull();\n    if (inner instanceof RpcPayload) {\n      // Immediately resolved to payload.\n      inner.deliverTo(parent, property, promises);\n    } else {\n      // It's a promise.\n      promises.push(inner.then(payload => {\n        let subPromises: Promise<unknown>[] = [];\n        payload.deliverTo(parent, property, subPromises);\n        if (subPromises.length > 0) {\n          return Promise.all(subPromises);\n        }\n      }));\n    }\n  }\n\n  // Call the given function with the payload as an argument. The call is made synchronously if\n  // possible, in order to maintain e-order. However, if any RpcPromises exist in the payload,\n  // they are awaited and substituted before calling the function. The result of the call is\n  // wrapped into another payload.\n  //\n  // The payload is automatically disposed after the call completes. The caller should not call\n  // dispose().\n  public async deliverCall(func: Function, thisArg: object | undefined): Promise<RpcPayload> {\n    try {\n      let promises: Promise<void>[] = [];\n      this.deliverTo(this, \"value\", promises);\n\n      // WARNING: It is critical that if the promises list is empty, we do not await anything, so\n      //   that the function is called immediately and synchronously. Otherwise, we might violate\n      //   e-order.\n      if (promises.length > 0) {\n        await Promise.all(promises);\n      }\n\n      // Call the function.\n      let result = Function.prototype.apply.call(func, thisArg, this.value);\n\n      if (result instanceof RpcPromise) {\n        // Special case: If the function immediately returns RpcPromise, we don't want to await it,\n        // since that will actually wait for the promise. Instead we want to construct a payload\n        // around it directly.\n        return RpcPayload.fromAppReturn(result);\n      } else {\n        // In all other cases, await the result (which may or may not be a promise, but `await`\n        // will just pass through non-promises).\n        return RpcPayload.fromAppReturn(await result);\n      }\n    } finally {\n      this.dispose();\n    }\n  }\n\n  // Produce a promise for this payload for return to the application. Any RpcPromises in the\n  // payload are awaited and substituted with their results first.\n  //\n  // The returned object will have a disposer which disposes the payload. The caller should not\n  // separately dispose it.\n  public async deliverResolve(): Promise<unknown> {\n    try {\n      let promises: Promise<void>[] = [];\n      this.deliverTo(this, \"value\", promises);\n\n      if (promises.length > 0) {\n        await Promise.all(promises);\n      }\n\n      let result = this.value;\n\n      // Add disposer to result.\n      if (result instanceof Object) {\n        if (!(Symbol.dispose in result)) {\n          // We want the disposer to be non-enumerable as otherwise it gets in the way of things\n          // like unit tests trying to deep-compare the result to an object.\n          Object.defineProperty(result, Symbol.dispose, {\n            // NOTE: Using `this.dispose.bind(this)` here causes Playwright's build of\n            //   Chromium 140.0.7339.16 to fail when the object is assigned to a `using` variable,\n            //   with the error:\n            //       TypeError: Symbol(Symbol.dispose) is not a function\n            //   I cannot reproduce this problem in Chrome 140.0.7339.127 nor in Node or workerd,\n            //   so maybe it was a short-lived V8 bug or something. To be safe, though, we use\n            //   `() => this.dispose()`, which seems to always work.\n            value: () => this.dispose(),\n            writable: true,\n            enumerable: false,\n            configurable: true,\n          });\n        }\n      }\n\n      return result;\n    } catch (err) {\n      // Automatically dispose since the application will never receive the disposable...\n      this.dispose();\n      throw err;\n    }\n  }\n\n  public dispose() {\n    if (this.source === \"owned\") {\n      // Oh good, we can just run through them.\n      this.stubs!.forEach(stub => stub[Symbol.dispose]());\n      this.promises!.forEach(promise => promise.promise[Symbol.dispose]());\n    } else if (this.source === \"return\") {\n      // Value received directly from app as a return value. We take ownership of all stubs, so we\n      // must recursively scan it for things to dispose.\n      this.disposeImpl(this.value, undefined);\n      if (this.rpcTargets && this.rpcTargets.size > 0) {\n        throw new Error(\"Not all rpcTargets were accounted for in disposeImpl()?\");\n      }\n    } else {\n      // this.source is \"params\". We don't own the stubs within.\n    }\n\n    // Make dispose() idempotent.\n    this.source = \"owned\";\n    this.stubs = [];\n    this.promises = [];\n  }\n\n  // Recursive dispose, called only when `source` is \"return\".\n  private disposeImpl(value: unknown, parent: object | undefined) {\n    let kind = typeForRpc(value);\n    switch (kind) {\n      case \"unsupported\":\n      case \"primitive\":\n      case \"bigint\":\n      case \"bytes\":\n      case \"date\":\n      case \"error\":\n      case \"undefined\":\n        return;\n\n      case \"array\": {\n        let array = <Array<unknown>>value;\n        let len = array.length;\n        for (let i = 0; i < len; i++) {\n          this.disposeImpl(array[i], array);\n        }\n        return;\n      }\n\n      case \"object\": {\n        let object = <Record<string, unknown>>value;\n        for (let i in object) {\n          this.disposeImpl(object[i], object);\n        }\n        return;\n      }\n\n      case \"stub\":\n      case \"rpc-promise\": {\n        let stub = <RpcStub>value;\n        let hook = unwrapStubNoProperties(stub);\n        if (hook) {\n          hook.dispose();\n        }\n        return;\n      }\n\n      case \"function\":\n      case \"rpc-target\": {\n        let target = <RpcTarget | Function>value;\n        let hook = this.rpcTargets?.get(target);\n        if (hook) {\n          // We created a hook around this target earlier. Dispose it now.\n          hook.dispose();\n          this.rpcTargets!.delete(target);\n        } else {\n          // There never was a stub pointing at this target. This could be because:\n          // * The call was used only for promise pipelining, so the result was never serialized,\n          //   so it never got added to `rpcTargets`.\n          // * The same RpcTarget appears in the results twice, and we already disposed the hook\n          //   when we saw it earlier. Note that it's intentional that we should call the disposer\n          //   twice if the same object appears twice.\n          disposeRpcTarget(target);\n        }\n        return;\n      }\n\n      case \"rpc-thenable\":\n        // Since thenables are promises, we don't own them, so we don't dispose them.\n        return;\n\n      default:\n        kind satisfies never;\n        return;\n    }\n  }\n\n  // Ignore unhandled rejections in all promises in this payload -- that is, all promises that\n  // *would* be awaited if this payload were to be delivered. See the similarly-named method of\n  // StubHook for explanation.\n  ignoreUnhandledRejections(): void {\n    if (this.stubs) {\n      // Propagate to all stubs and promises.\n      this.stubs.forEach(stub => {\n        unwrapStubOrParent(stub).ignoreUnhandledRejections();\n      });\n      this.promises!.forEach(\n          promise => unwrapStubOrParent(promise.promise).ignoreUnhandledRejections());\n    } else {\n      // Ugh we have to walk the tree.\n      this.ignoreUnhandledRejectionsImpl(this.value);\n    }\n  }\n\n  private ignoreUnhandledRejectionsImpl(value: unknown) {\n    let kind = typeForRpc(value);\n    switch (kind) {\n      case \"unsupported\":\n      case \"primitive\":\n      case \"bigint\":\n      case \"bytes\":\n      case \"date\":\n      case \"error\":\n      case \"undefined\":\n      case \"function\":\n      case \"rpc-target\":\n        return;\n\n      case \"array\": {\n        let array = <Array<unknown>>value;\n        let len = array.length;\n        for (let i = 0; i < len; i++) {\n          this.ignoreUnhandledRejectionsImpl(array[i]);\n        }\n        return;\n      }\n\n      case \"object\": {\n        let object = <Record<string, unknown>>value;\n        for (let i in object) {\n          this.ignoreUnhandledRejectionsImpl(object[i]);\n        }\n        return;\n      }\n\n      case \"stub\":\n      case \"rpc-promise\":\n        unwrapStubOrParent(<RpcStub>value).ignoreUnhandledRejections();\n        return;\n\n      case \"rpc-thenable\":\n        (<any>value).then((_: any) => {}, (_: any) => {});\n        return;\n\n      default:\n        kind satisfies never;\n        return;\n    }\n  }\n};\n\n// =======================================================================================\n// Local StubHook implementations\n\n// Result of followPath().\ntype FollowPathResult = {\n  // Path led to a regular value.\n\n  value: unknown,              // the value\n  parent: object | undefined,  // the immediate parent (useful as `this` if making a call)\n  owner: RpcPayload | null,    // RpcPayload that owns the value, if any\n\n  hook?: never,\n  remainingPath?: never,\n} | {\n  // Path leads into another stub, which needs to be called recursively.\n\n  hook: StubHook,               // StubHook of the inner stub.\n  remainingPath: PropertyPath,  // Path to pass to `hook` when recursing.\n\n  value?: never,\n  parent?: never,\n  owner?: never,\n};\n\nfunction followPath(value: unknown, parent: object | undefined,\n                    path: PropertyPath, owner: RpcPayload | null): FollowPathResult {\n  for (let i = 0; i < path.length; i++) {\n    parent = <object>value;\n\n    let part = path[i];\n    if (part in Object.prototype) {\n      // Don't allow messing with Object.prototype properties over RPC. We block these even if\n      // the specific object has overridden them for consistency with the deserialization code,\n      // which will refuse to deserialize an object containing such properties. Anyway, it's\n      // impossible for a normal client to even request these because accessing Object prototype\n      // properties on a stub will resolve to the local prototype property, not making an RPC at\n      // all.\n      value = undefined;\n      continue;\n    }\n\n    let kind = typeForRpc(value);\n    switch (kind) {\n      case \"object\":\n      case \"function\":\n        // Must be own property, NOT inherited from a prototype.\n        if (Object.hasOwn(<object>value, part)) {\n          value = (<any>value)[part];\n        } else {\n          value = undefined;\n        }\n        break;\n\n      case \"array\":\n        // For arrays, restrict specifically to numeric indexes, to be consistent with\n        // serialization, which only sends a flat list.\n        if (Number.isInteger(part) && <number>part >= 0) {\n          value = (<any>value)[part];\n        } else {\n          value = undefined;\n        }\n        break;\n\n      case \"rpc-target\":\n      case \"rpc-thenable\": {\n        // Must be prototype property, and must NOT be inherited from `Object`.\n        if (Object.hasOwn(<object>value, part)) {\n          // We throw an error in this case, rather than return undefined, because otherwise\n          // people tend to get confused about this. If you don't want it to be possible to\n          // probe the existence of your instance properties, make them properly private (prefix\n          // with #).\n          throw new TypeError(\n              `Attempted to access property '${part}', which is an instance property of the ` +\n              `RpcTarget. To avoid leaking private internals, instance properties cannot be ` +\n              `accessed over RPC. If you want to make this property available over RPC, define ` +\n              `it as a method or getter on the class, instead of an instance property.`);\n        } else {\n          value = (<any>value)[part];\n        }\n\n        // Since we're descending into the RpcTarget, the rest of the path is not \"owned\" by any\n        // RpcPayload.\n        owner = null;\n        break;\n      }\n\n      case \"stub\":\n      case \"rpc-promise\": {\n        let {hook: hook, pathIfPromise} = unwrapStubAndPath(<RpcStub>value);\n        return { hook, remainingPath:\n            pathIfPromise ? pathIfPromise.concat(path.slice(i)) : path.slice(i) };\n      }\n\n      case \"primitive\":\n      case \"bigint\":\n      case \"bytes\":\n      case \"date\":\n      case \"error\":\n        // These have no properties that can be accessed remotely.\n        value = undefined;\n        break;\n\n      case \"undefined\":\n        // Intentionally produce TypeError.\n        value = (value as any)[part];\n        break;\n\n      case \"unsupported\": {\n        if (i === 0) {\n          throw new TypeError(`RPC stub points at a non-serializable type.`);\n        } else {\n          let prefix = path.slice(0, i).join(\".\");\n          let remainder = path.slice(0, i).join(\".\");\n          throw new TypeError(\n              `'${prefix}' is not a serializable type, so property ${remainder} cannot ` +\n              `be accessed.`);\n        }\n      }\n\n      default:\n        kind satisfies never;\n        throw new TypeError(\"unreachable\");\n    }\n  }\n\n  // If we reached a promise, we actually want the caller to forward to the promise, not return\n  // the promise itself.\n  if (value instanceof RpcPromise) {\n    let {hook: hook, pathIfPromise} = unwrapStubAndPath(<RpcStub>value);\n    return { hook, remainingPath: pathIfPromise || [] };\n  }\n\n  // We don't validate the final value itself because we don't know the intended use yet. If it's\n  // for a call, any callable is valid. If it's for get(), then any serializable value is valid.\n  return {\n    value,\n    parent,\n    owner,\n  };\n}\n\n// Shared base class for PayloadStubHook and TargetStubHook.\nabstract class ValueStubHook extends StubHook {\n  protected abstract getValue(): {value: unknown, owner: RpcPayload | null};\n\n  call(path: PropertyPath, args: RpcPayload): StubHook {\n    try {\n      let {value, owner} = this.getValue();\n      let followResult = followPath(value, undefined, path, owner);\n\n      if (followResult.hook) {\n        return followResult.hook.call(followResult.remainingPath, args);\n      }\n\n      // It's a local function.\n      if (typeof followResult.value != \"function\") {\n        throw new TypeError(`'${path.join('.')}' is not a function.`);\n      }\n      let promise = args.deliverCall(followResult.value, followResult.parent);\n      return new PromiseStubHook(promise.then(payload => {\n        return new PayloadStubHook(payload);\n      }));\n    } catch (err) {\n      return new ErrorStubHook(err);\n    }\n  }\n\n  map(path: PropertyPath, captures: StubHook[], instructions: unknown[]): StubHook {\n    try {\n      let followResult: FollowPathResult;\n      try {\n        let {value, owner} = this.getValue();\n        followResult = followPath(value, undefined, path, owner);;\n      } catch (err) {\n        // Oops, we need to dispose the captures of which we took ownership.\n        for (let cap of captures) {\n          cap.dispose();\n        }\n        throw err;\n      }\n\n      if (followResult.hook) {\n        return followResult.hook.map(followResult.remainingPath, captures, instructions);\n      }\n\n      return mapImpl.applyMap(\n          followResult.value, followResult.parent, followResult.owner, captures, instructions);\n    } catch (err) {\n      return new ErrorStubHook(err);\n    }\n  }\n\n  get(path: PropertyPath): StubHook {\n    try {\n      let {value, owner} = this.getValue();\n\n      if (path.length === 0 && owner === null) {\n        // The only way this happens is if someone sends \"pipeline\" and references a\n        // TargetStubHook, but they shouldn't do that, because TargetStubHook never backs a\n        // promise, and a non-promise cannot be converted to a promise.\n        // TODO: Is this still correct for rpc-thenable?\n        throw new Error(\"Can't dup an RpcTarget stub as a promise.\");\n      }\n\n      let followResult = followPath(value, undefined, path, owner);\n\n      if (followResult.hook) {\n        return followResult.hook.get(followResult.remainingPath);\n      }\n\n      // Note that if `followResult.owner` is null, then we've descended into the contents of an\n      // RpcTarget. In that case, if this deep copy discovers an RpcTarget embedded in the result,\n      // it will create a new stub for it. If that RpcTarget has a disposer, it'll be disposed when\n      // that stub is disposed. If the same RpcTarget is returned in *another* get(), it create\n      // *another* stub, which calls the disposer *another* time. This can be quite weird -- the\n      // disposer may be called any number of times, including zero if the property is never read\n      // at all. Unfortunately, that's just the way it is. The application can avoid this problem by\n      // wrapping the RpcTarget in an RpcStub itself, proactively, and using that as the property --\n      // then, each time the property is get()ed, a dup() of that stub is returned.\n      return new PayloadStubHook(RpcPayload.deepCopyFrom(\n          followResult.value, followResult.parent, followResult.owner));\n    } catch (err) {\n      return new ErrorStubHook(err);\n    }\n  }\n}\n\n// StubHook wrapping an RpcPayload in local memory.\n//\n// This is used for:\n// - Resolution of a promise.\n//   - Initially on the server side, where it can be pull()ed and used in pipelining.\n//   - On the client side, after pull() has transmitted the payload.\n// - Implementing RpcTargets, on the server side.\n//   - Since the payload's root is an RpcTarget, pull()ing it will just duplicate the stub.\nexport class PayloadStubHook extends ValueStubHook {\n  constructor(payload: RpcPayload) {\n    super();\n    this.payload = payload;\n  }\n\n  private payload?: RpcPayload;  // cleared when disposed\n\n  private getPayload(): RpcPayload {\n    if (this.payload) {\n      return this.payload;\n    } else {\n      throw new Error(\"Attempted to use an RPC StubHook after it was disposed.\");\n    }\n  }\n\n  protected getValue() {\n    let payload = this.getPayload();\n    return {value: payload.value, owner: payload};\n  }\n\n  dup(): StubHook {\n    // Although dup() is documented as not copying the payload, what this really means is that\n    // you aren't expected to be able to pull() from a dup()ed hook if it is remote. However,\n    // PayloadStubHook already has the value locally, and there's nothing we can do except clone\n    // it here.\n    //\n    // TODO: Should we prohibit pull()ing from the clone? The fact that it'll be wrapped as\n    //   RpcStub instead of RpcPromise should already prevent this...\n    let thisPayload = this.getPayload();\n    return new PayloadStubHook(RpcPayload.deepCopyFrom(\n        thisPayload.value, undefined, thisPayload));\n  }\n\n  pull(): RpcPayload | Promise<RpcPayload> {\n    // Reminder: pull() intentionally returns the hook's own payload and not a clone. The caller\n    // only needs to dispose one of the hook or the payload. It is the caller's responsibility\n    // to not dispose the payload if they intend to keep the hook around.\n    return this.getPayload();\n  }\n\n  ignoreUnhandledRejections(): void {\n    if (this.payload) {\n      this.payload.ignoreUnhandledRejections();\n    }\n  }\n\n  dispose(): void {\n    if (this.payload) {\n      this.payload.dispose();\n      this.payload = undefined;\n    }\n  }\n\n  onBroken(callback: (error: any) => void): void {\n    if (this.payload) {\n      if (this.payload.value instanceof RpcStub) {\n        // Payload is a single stub, we should forward onRpcBroken to it.\n        // TODO: Consider prohibiting PayloadStubHook created around a single stub; should always\n        //   use the underlying stub's hook instead?\n        this.payload.value.onRpcBroken(callback);\n      }\n\n      // TODO: Should native stubs be able to implement onRpcBroken?\n    }\n  }\n}\n\nfunction disposeRpcTarget(target: RpcTarget | Function) {\n  if (Symbol.dispose in target) {\n    try {\n      ((<Disposable><any>target)[Symbol.dispose])();\n    } catch (err) {\n      // We don't actually want to throw from dispose() as this will create trouble for\n      // the RPC state machine. Instead, treat the application's error as an unhandled\n      // rejection.\n      Promise.reject(err);\n    }\n  }\n}\n\n// Many TargetStubHooks could point at the same RpcTarget. We store a refcount in a separate\n// object that they all share.\n//\n// We can't store the refcount on the RpcTarget itself because if the application chooses to pass\n// the same RpcTarget into the RPC system multiple times, we need to call this disposer multiple\n// times for consistency.\ntype BoxedRefcount = { count: number };\n\n// StubHook which wraps an RpcTarget. This has similarities to PayloadStubHook (especially when\n// the root of the payload happens to be an RpcTarget), but there can only be one RpcPayload\n// pointing at an RpcTarget whereas there can be several TargetStubHooks pointing at it. Also,\n// TargetStubHook cannot be pull()ed, because it always backs an RpcStub, not an RpcPromise.\nclass TargetStubHook extends ValueStubHook {\n  // Constructs a TargetStubHook that is not duplicated from an existing hook.\n  //\n  // If `value` is a function, `parent` is bound as its \"this\".\n  static create(value: RpcTarget | Function, parent: object | undefined) {\n    if (typeof value !== \"function\") {\n      // If the target isn't callable, we don't need to pass a `this` to it, so drop `parent`.\n      // NOTE: `typeof value === \"function\"` checks if the value is callable. This technically\n      //   works even for `RpcTarget` implementations that are callable, not just plain functions.\n      parent = undefined;\n    }\n    return new TargetStubHook(value, parent);\n  }\n\n  private constructor(target: RpcTarget | Function,\n                      parent?: object | undefined,\n                      dupFrom?: TargetStubHook) {\n    super();\n    this.target = target;\n    this.parent = parent;\n    if (dupFrom) {\n      if (dupFrom.refcount) {\n        this.refcount = dupFrom.refcount;\n        ++this.refcount.count;\n      }\n    } else if (Symbol.dispose in target) {\n      // Disposer present, so we need to refcount.\n      this.refcount = {count: 1};\n    }\n  }\n\n  private target?: RpcTarget | Function;  // cleared when disposed\n  private parent?: object | undefined;  // `this` parameter when calling `target`\n  private refcount?: BoxedRefcount;  // undefined if not needed (because target has no disposer)\n\n  private getTarget(): RpcTarget | Function {\n    if (this.target) {\n      return this.target;\n    } else {\n      throw new Error(\"Attempted to use an RPC StubHook after it was disposed.\");\n    }\n  }\n\n  protected getValue() {\n    return {value: this.getTarget(), owner: null};\n  }\n\n  dup(): StubHook {\n    return new TargetStubHook(this.getTarget(), this.parent, this);\n  }\n\n  pull(): RpcPayload | Promise<RpcPayload> {\n    let target = this.getTarget();\n    if (\"then\" in target) {\n      // If the target is itself thenable, we allow it to be treated as a promise. This is used\n      // in particular to support wrapping a workerd-native RpcPromise or RpcProperty.\n      return Promise.resolve(target).then(resolution => {\n        return RpcPayload.fromAppReturn(resolution);\n      });\n    } else {\n      // This shouldn't be called since RpcTarget always becomes RpcStub, not RpcPromise, and you\n      // can only pull a promise.\n      return Promise.reject(new Error(\"Tried to resolve a non-promise stub.\"));\n    }\n  }\n\n  ignoreUnhandledRejections(): void {\n    // Nothing to do.\n  }\n\n  dispose(): void {\n    if (this.target) {\n      if (this.refcount) {\n        if (--this.refcount.count == 0) {\n          disposeRpcTarget(this.target);\n        }\n      }\n\n      this.target = undefined;\n    }\n  }\n\n  onBroken(callback: (error: any) => void): void {\n    // TODO: Should RpcTargets be able to implement onRpcBroken?\n  }\n}\n\n// StubHook derived from a Promise for some other StubHook. Waits for the promise and then\n// forward calls, being careful to honor e-order.\nclass PromiseStubHook extends StubHook {\n  private promise: Promise<StubHook>;\n  private resolution: StubHook | undefined;\n\n  constructor(promise: Promise<StubHook>) {\n    super();\n\n    this.promise = promise.then(res => { this.resolution = res; return res; });\n  }\n\n  call(path: PropertyPath, args: RpcPayload): StubHook {\n    // Note: We can't use `resolution` even if it's available because it could technically break\n    //   e-order: A call() that arrives just after the resolution could be delivered faster than\n    //   a call() that arrives just before. Keeping the promise around and always waiting on it\n    //   avoids the problem.\n    // TODO: Is there a way around this?\n\n    // Once call() returns (synchronously), we can no longer touch the original args. Since we\n    // can't serialize them yet, we have to deep-copy them now.\n    args.ensureDeepCopied();\n\n    return new PromiseStubHook(this.promise.then(hook => hook.call(path, args)));\n  }\n\n  map(path: PropertyPath, captures: StubHook[], instructions: unknown[]): StubHook {\n    return new PromiseStubHook(this.promise.then(\n        hook => hook.map(path, captures, instructions),\n        err => {\n          for (let cap of captures) {\n            cap.dispose();\n          }\n          throw err;\n        }));\n  }\n\n  get(path: PropertyPath): StubHook {\n    // Note: e-order matters for get(), just like call(), in case the property has a getter.\n    return new PromiseStubHook(this.promise.then(hook => hook.get(path)));\n  }\n\n  dup(): StubHook {\n    if (this.resolution) {\n      return this.resolution.dup();\n    } else {\n      return new PromiseStubHook(this.promise.then(hook => hook.dup()));\n    }\n  }\n\n  pull(): RpcPayload | Promise<RpcPayload> {\n    // Luckily, resolutions are not subject to e-order, so it's safe to use `this.resolution`\n    // here. In fact, it is required to maintain e-order elsewhere: If this promise is being used\n    // as the input to some other local call (via promise pipelining), we need to make sure that\n    // other call is not delayed at all when this promise is already resolved.\n    if (this.resolution) {\n      return this.resolution.pull();\n    } else {\n      return this.promise.then(hook => hook.pull());\n    }\n  }\n\n  ignoreUnhandledRejections(): void {\n    if (this.resolution) {\n      this.resolution.ignoreUnhandledRejections();\n    } else {\n      this.promise.then(res => {\n        res.ignoreUnhandledRejections();\n      }, err => {\n        // Ignore the error!\n      });\n    }\n  }\n\n  dispose(): void {\n    if (this.resolution) {\n      this.resolution.dispose();\n    } else {\n      this.promise.then(hook => {\n        hook.dispose();\n      }, err => {\n        // nothing to dispose\n      });\n    }\n  }\n\n  onBroken(callback: (error: any) => void): void {\n    if (this.resolution) {\n      this.resolution.onBroken(callback);\n    } else {\n      this.promise.then(hook => {\n        hook.onBroken(callback);\n      }, callback);\n    }\n  }\n}\n","// Copyright (c) 2025 Cloudflare, Inc.\n// Licensed under the MIT license found in the LICENSE.txt file or at:\n//     https://opensource.org/license/mit\n\nimport { StubHook, RpcPayload, typeForRpc, RpcStub, RpcPromise, LocatedPromise, RpcTarget, PropertyPath, unwrapStubAndPath } from \"./core.js\";\n\nexport type ImportId = number;\nexport type ExportId = number;\n\n// =======================================================================================\n\nexport interface Exporter {\n  exportStub(hook: StubHook): ExportId;\n  exportPromise(hook: StubHook): ExportId;\n  getImport(hook: StubHook): ImportId | undefined;\n\n  // If a serialization error occurs after having exported some capabilities, this will be called\n  // to roll back the exports.\n  unexport(ids: Array<ExportId>): void;\n\n  onSendError(error: Error): Error | void;\n}\n\nclass NullExporter implements Exporter {\n  exportStub(stub: StubHook): never {\n    throw new Error(\"Cannot serialize RPC stubs without an RPC session.\");\n  }\n  exportPromise(stub: StubHook): never {\n    throw new Error(\"Cannot serialize RPC stubs without an RPC session.\");\n  }\n  getImport(hook: StubHook): ImportId | undefined {\n    return undefined;\n  }\n  unexport(ids: Array<ExportId>): void {}\n\n  onSendError(error: Error): Error | void {}\n}\n\nconst NULL_EXPORTER = new NullExporter();\n\n// Maps error name to error class for deserialization.\nconst ERROR_TYPES: Record<string, any> = {\n  Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, AggregateError,\n  // TODO: DOMError? Others?\n};\n\n// Polyfill type for UInt8Array.toBase64(), which has started landing in JS runtimes but is not\n// supported everywhere just yet.\ninterface Uint8Array {\n  toBase64?(options?: {\n    alphabet?: \"base64\" | \"base64url\",\n    omitPadding?: boolean\n  }): string;\n};\n\ninterface FromBase64 {\n  fromBase64?(text: string, options?: {\n    alphabet?: \"base64\" | \"base64url\",\n    lastChunkHandling?: \"loose\" | \"strict\" | \"stop-before-partial\"\n  }): Uint8Array;\n}\n\n// Converts fully-hydrated messages into object trees that are JSON-serializable for sending over\n// the wire. This is used to implement serialization -- but it doesn't take the last step of\n// actually converting to a string. (The name is meant to be the opposite of \"Evaluator\", which\n// implements the opposite direction.)\nexport class Devaluator {\n  private constructor(private exporter: Exporter, private source: RpcPayload | undefined) {}\n\n  // Devaluate the given value.\n  // * value: The value to devaluate.\n  // * parent: The value's parent object, which would be used as `this` if the value were called\n  //     as a function.\n  // * exporter: Callbacks to the RPC session for exporting capabilities found in this message.\n  // * source: The RpcPayload which contains the value, and therefore owns stubs within.\n  //\n  // Returns: The devaluated value, ready to be JSON-serialized.\n  public static devaluate(\n      value: unknown, parent?: object, exporter: Exporter = NULL_EXPORTER, source?: RpcPayload)\n      : unknown {\n    let devaluator = new Devaluator(exporter, source);\n    try {\n      return devaluator.devaluateImpl(value, parent, 0);\n    } catch (err) {\n      if (devaluator.exports) {\n        try {\n          exporter.unexport(devaluator.exports);\n        } catch (err) {\n          // probably a side effect of the original error, ignore it\n        }\n      }\n      throw err;\n    }\n  }\n\n  private exports?: Array<ExportId>;\n\n  private devaluateImpl(value: unknown, parent: object | undefined, depth: number): unknown {\n    if (depth >= 64) {\n      throw new Error(\n          \"Serialization exceeded maximum allowed depth. (Does the message contain cycles?)\");\n    }\n\n    let kind = typeForRpc(value);\n    switch (kind) {\n      case \"unsupported\": {\n        let msg;\n        try {\n          msg = `Cannot serialize value: ${value}`;\n        } catch (err) {\n          msg = \"Cannot serialize value: (couldn't stringify value)\";\n        }\n        throw new TypeError(msg);\n      }\n\n      case \"primitive\":\n        if (typeof value === \"number\" && !isFinite(value)) {\n          if (value === Infinity) {\n            return [\"inf\"];\n          } else if (value === -Infinity) {\n            return [\"-inf\"];\n          } else {\n            return [\"nan\"];\n          }\n        } else {\n          // Supported directly by JSON.\n          return value;\n        }\n\n      case \"object\": {\n        let object = <Record<string, unknown>>value;\n        let result: Record<string, unknown> = {};\n        for (let key in object) {\n          result[key] = this.devaluateImpl(object[key], object, depth + 1);\n        }\n        return result;\n      }\n\n      case \"array\": {\n        let array = <Array<unknown>>value;\n        let len = array.length;\n        let result = new Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = this.devaluateImpl(array[i], array, depth + 1);\n        }\n        // Wrap literal arrays in an outer one-element array, to \"escape\" them.\n        return [result];\n      }\n\n      case \"bigint\":\n        return [\"bigint\", (<bigint>value).toString()];\n\n      case \"date\":\n        return [\"date\", (<Date>value).getTime()];\n\n      case \"bytes\": {\n        let bytes = value as Uint8Array;\n        if (bytes.toBase64) {\n          return [\"bytes\", bytes.toBase64({omitPadding: true})];\n        } else {\n          return [\"bytes\",\n              btoa(String.fromCharCode.apply(null, bytes as number[]).replace(/=*$/, \"\"))];\n        }\n      }\n\n      case \"error\": {\n        let e = <Error>value;\n\n        // TODO:\n        // - Determine type by checking prototype rather than `name`, which can be overridden?\n        // - Serialize cause / suppressed error / etc.\n        // - Serialize added properties.\n\n        let rewritten = this.exporter.onSendError(e);\n        if (rewritten) {\n          e = rewritten;\n        }\n\n        let result = [\"error\", e.name, e.message];\n        if (rewritten && rewritten.stack) {\n          result.push(rewritten.stack);\n        }\n        return result;\n      }\n\n      case \"undefined\":\n        return [\"undefined\"];\n\n      case \"stub\":\n      case \"rpc-promise\": {\n        if (!this.source) {\n          throw new Error(\"Can't serialize RPC stubs in this context.\");\n        }\n\n        let {hook, pathIfPromise} = unwrapStubAndPath(<RpcStub>value);\n        let importId = this.exporter.getImport(hook);\n        if (importId !== undefined) {\n          if (pathIfPromise) {\n            // It's a promise pointing back to the peer, so we are doing pipelining here.\n            if (pathIfPromise.length > 0) {\n              return [\"pipeline\", importId, pathIfPromise];\n            } else {\n              return [\"pipeline\", importId];\n            }\n          } else {\n            return [\"import\", importId];\n          }\n        }\n\n        if (pathIfPromise) {\n          hook = hook.get(pathIfPromise);\n        } else {\n          hook = hook.dup();\n        }\n\n        return this.devaluateHook(pathIfPromise ? \"promise\" : \"export\", hook);\n      }\n\n      case \"function\":\n      case \"rpc-target\": {\n        if (!this.source) {\n          throw new Error(\"Can't serialize RPC stubs in this context.\");\n        }\n\n        let hook = this.source.getHookForRpcTarget(<RpcTarget|Function>value, parent);\n        return this.devaluateHook(\"export\", hook);\n      }\n\n      case \"rpc-thenable\": {\n        if (!this.source) {\n          throw new Error(\"Can't serialize RPC stubs in this context.\");\n        }\n\n        let hook = this.source.getHookForRpcTarget(<RpcTarget>value, parent);\n        return this.devaluateHook(\"promise\", hook);\n      }\n\n      default:\n        kind satisfies never;\n        throw new Error(\"unreachable\");\n    }\n  }\n\n  private devaluateHook(type: \"export\" | \"promise\", hook: StubHook): unknown {\n    if (!this.exports) this.exports = [];\n    let exportId = type === \"promise\" ? this.exporter.exportPromise(hook)\n                                      : this.exporter.exportStub(hook);\n    this.exports.push(exportId);\n    return [type, exportId];\n  }\n}\n\n/**\n * Serialize a value, using Cap'n Web's underlying serialization. This won't be able to serialize\n * RPC stubs, but it will support basic data types.\n */\nexport function serialize(value: unknown): string {\n  return JSON.stringify(Devaluator.devaluate(value));\n}\n\n// =======================================================================================\n\nexport interface Importer {\n  importStub(idx: ImportId): StubHook;\n  importPromise(idx: ImportId): StubHook;\n  getExport(idx: ExportId): StubHook | undefined;\n}\n\nclass NullImporter implements Importer {\n  importStub(idx: ImportId): never {\n    throw new Error(\"Cannot deserialize RPC stubs without an RPC session.\");\n  }\n  importPromise(idx: ImportId): never {\n    throw new Error(\"Cannot deserialize RPC stubs without an RPC session.\");\n  }\n  getExport(idx: ExportId): StubHook | undefined {\n    return undefined;\n  }\n}\n\nconst NULL_IMPORTER = new NullImporter();\n\n// Takes object trees parse from JSON and converts them into fully-hydrated JavaScript objects for\n// delivery to the app. This is used to implement deserialization, except that it doesn't actually\n// start from a raw string.\nexport class Evaluator {\n  constructor(private importer: Importer) {}\n\n  private stubs: RpcStub[] = [];\n  private promises: LocatedPromise[] = [];\n\n  public evaluate(value: unknown): RpcPayload {\n    let payload = RpcPayload.forEvaluate(this.stubs, this.promises);\n    try {\n      payload.value = this.evaluateImpl(value, payload, \"value\");\n      return payload;\n    } catch (err) {\n      payload.dispose();\n      throw err;\n    }\n  }\n\n  // Evaluate the value without destroying it.\n  public evaluateCopy(value: unknown): RpcPayload {\n    return this.evaluate(structuredClone(value));\n  }\n\n  private evaluateImpl(value: unknown, parent: object, property: string | number): unknown {\n    if (value instanceof Array) {\n      if (value.length == 1 && value[0] instanceof Array) {\n        // Escaped array. Evaluate the contents.\n        let result = value[0];\n        for (let i = 0; i < result.length; i++) {\n          result[i] = this.evaluateImpl(result[i], result, i);\n        }\n        return result;\n      } else switch (value[0]) {\n        case \"bigint\":\n          if (typeof value[1] == \"string\") {\n            return BigInt(value[1]);\n          }\n          break;\n        case \"date\":\n          if (typeof value[1] == \"number\") {\n            return new Date(value[1]);\n          }\n          break;\n        case \"bytes\": {\n          let b64 = Uint8Array as FromBase64;\n          if (typeof value[1] == \"string\") {\n            if (b64.fromBase64) {\n              return b64.fromBase64(value[1]);\n            } else {\n              let bs = atob(value[1]);\n              let len = bs.length;\n              let bytes = new Uint8Array(len);\n              for (let i = 0; i < len; i++) {\n                bytes[i] = bs.charCodeAt(i);\n              }\n              return bytes;\n            }\n          }\n          break;\n        }\n        case \"error\":\n          if (value.length >= 3 && typeof value[1] === \"string\" && typeof value[2] === \"string\") {\n            let cls = ERROR_TYPES[value[1]] || Error;\n            let result = new cls(value[2]);\n            if (typeof value[3] === \"string\") {\n              result.stack = value[3];\n            }\n            return result;\n          }\n          break;\n        case \"undefined\":\n          if (value.length === 1) {\n            return undefined;\n          }\n          break;\n        case \"inf\":\n          return Infinity;\n        case \"-inf\":\n          return -Infinity;\n        case \"nan\":\n          return NaN;\n\n        case \"import\":\n        case \"pipeline\": {\n          // It's an \"import\" from the perspective of the sender, so it's an export from our\n          // side. In other words, the sender is passing our own object back to us.\n\n          if (value.length < 2 || value.length > 4) {\n            break;   // report error below\n          }\n\n          // First parameter is import ID (from the sender's perspective, so export ID from\n          // ours).\n          if (typeof value[1] != \"number\") {\n            break;   // report error below\n          }\n\n          let hook = this.importer.getExport(value[1]);\n          if (!hook) {\n            throw new Error(`no such entry on exports table: ${value[1]}`);\n          }\n\n          let isPromise = value[0] == \"pipeline\";\n\n          let addStub = (hook: StubHook) => {\n            if (isPromise) {\n              let promise = new RpcPromise(hook, []);\n              this.promises.push({promise, parent, property});\n              return promise;\n            } else {\n              let stub = new RpcPromise(hook, []);\n              this.stubs.push(stub);\n              return stub;\n            }\n          };\n\n          if (value.length == 2) {\n            // Just referencing the export itself.\n            if (isPromise) {\n              // We need to use hook.get([]) to make sure we get a promise hook.\n              return addStub(hook.get([]));\n            } else {\n              // dup() returns a stub hook.\n              return addStub(hook.dup());\n            }\n          }\n\n          // Second parameter, if given, is a property path.\n          let path = value[2];\n          if (!(path instanceof Array)) {\n            break;  // report error below\n          }\n          if (!path.every(\n              part => { return typeof part == \"string\" || typeof part == \"number\"; })) {\n            break;  // report error below\n          }\n\n          if (value.length == 3) {\n            // Just referencing the path, not a call.\n            return addStub(hook.get(path));\n          }\n\n          // Third parameter, if given, is call arguments. The sender has identified a function\n          // and wants us to call it.\n          //\n          // Usually this is used with \"pipeline\", in which case we evaluate to an\n          // RpcPromise. However, this can be used with \"import\", in which case the caller is\n          // asking that the result be coerced to RpcStub. This distinction matters if the\n          // result of this evaluation is to be passed as arguments to another call -- promises\n          // must be resolved in advance, but stubs can be passed immediately.\n          let args = value[3];\n          if (!(args instanceof Array)) {\n            break;  // report error below\n          }\n\n          // We need a new evaluator for the args, to build a separate payload.\n          let subEval = new Evaluator(this.importer);\n          args = subEval.evaluate([args]);\n\n          return addStub(hook.call(path, args));\n        }\n\n        case \"remap\": {\n          if (value.length !== 5 ||\n              typeof value[1] !== \"number\" ||\n              !(value[2] instanceof Array) ||\n              !(value[3] instanceof Array) ||\n              !(value[4] instanceof Array)) {\n            break;   // report error below\n          }\n\n          let hook = this.importer.getExport(value[1]);\n          if (!hook) {\n            throw new Error(`no such entry on exports table: ${value[1]}`);\n          }\n\n          let path = value[2];\n          if (!path.every(\n              part => { return typeof part == \"string\" || typeof part == \"number\"; })) {\n            break;  // report error below\n          }\n\n          let captures: StubHook[] = value[3].map(cap => {\n            if (!(cap instanceof Array) ||\n                cap.length !== 2 ||\n                (cap[0] !== \"import\" && cap[0] !== \"export\") ||\n                typeof cap[1] !== \"number\") {\n              throw new TypeError(`unknown map capture: ${JSON.stringify(cap)}`);\n            }\n\n            if (cap[0] === \"export\") {\n              return this.importer.importStub(cap[1]);\n            } else {\n              let exp = this.importer.getExport(cap[1]);\n              if (!exp) {\n                throw new Error(`no such entry on exports table: ${cap[1]}`);\n              }\n              return exp.dup();\n            }\n          });\n\n          let instructions = value[4];\n\n          let resultHook = hook.map(path, captures, instructions);\n\n          let promise = new RpcPromise(resultHook, []);\n          this.promises.push({promise, parent, property});\n          return promise;\n        }\n\n        case \"export\":\n        case \"promise\":\n          // It's an \"export\" from the perspective of the sender, i.e. they sent us a new object\n          // which we want to import.\n          //\n          // \"promise\" is same as \"export\" but should not be delivered to the application. If any\n          // promises appear in a value, they must be resolved and substituted with their results\n          // before delivery. Note that if the value being evaluated appeared in call params, or\n          // appeared in a resolve message for a promise that is being pulled, then the new promise\n          // is automatically also being pulled, otherwise it is not.\n          if (typeof value[1] == \"number\") {\n            if (value[0] == \"promise\") {\n              let hook = this.importer.importPromise(value[1]);\n              let promise = new RpcPromise(hook, []);\n              this.promises.push({parent, property, promise});\n              return promise;\n            } else {\n              let hook = this.importer.importStub(value[1]);\n              let stub = new RpcStub(hook);\n              this.stubs.push(stub);\n              return stub;\n            }\n          }\n          break;\n      }\n      throw new TypeError(`unknown special value: ${JSON.stringify(value)}`);\n    } else if (value instanceof Object) {\n      let result = <Record<string, unknown>>value;\n      for (let key in result) {\n        if (key in Object.prototype || key === \"toJSON\") {\n          // Out of an abundance of caution, we will ignore properties that override properties\n          // of Object.prototype. It's especially important that we don't allow `__proto__` as it\n          // may lead to prototype pollution. We also would rather not allow, e.g., `toString()`,\n          // as overriding this could lead to various mischief.\n          //\n          // We also block `toJSON()` for similar reasons -- even though Object.prototype doesn't\n          // actually define it, `JSON.stringify()` treats it specially and we don't want someone\n          // snooping on JSON calls.\n          //\n          // We do still evaluate the inner value so that we can properly release any stubs.\n          this.evaluateImpl(result[key], result, key);\n          delete result[key];\n        } else {\n          result[key] = this.evaluateImpl(result[key], result, key);\n        }\n      }\n      return result;\n    } else {\n      // Other JSON types just pass through.\n      return value;\n    }\n  }\n}\n\n/**\n * Deserialize a value serialized using serialize().\n */\nexport function deserialize(value: string): unknown {\n  let payload = new Evaluator(NULL_IMPORTER).evaluate(JSON.parse(value));\n  payload.dispose();  // should be no-op but just in case\n  return payload.value;\n}\n","// Copyright (c) 2025 Cloudflare, Inc.\n// Licensed under the MIT license found in the LICENSE.txt file or at:\n//     https://opensource.org/license/mit\n\nimport { StubHook, RpcPayload, RpcStub, PropertyPath, PayloadStubHook, ErrorStubHook, RpcTarget, unwrapStubAndPath } from \"./core.js\";\nimport { Devaluator, Evaluator, ExportId, ImportId, Exporter, Importer, serialize } from \"./serialize.js\";\n\n/**\n * Interface for an RPC transport, which is a simple bidirectional message stream. Implement this\n * interface if the built-in transports (e.g. for HTTP batch and WebSocket) don't meet your needs.\n */\nexport interface RpcTransport {\n  /**\n   * Sends a message to the other end.\n   */\n  send(message: string): Promise<void>;\n\n  /**\n   * Receives a message sent by the other end.\n   *\n   * If and when the transport becomes disconnected, this will reject. The thrown error will be\n   * propagated to all outstanding calls and future calls on any stubs associated with the session.\n   * If there are no outstanding calls (and none are made in the future), then the error does not\n   * propagate anywhere -- this is considered a \"clean\" shutdown.\n   */\n  receive(): Promise<string>;\n\n  /**\n   * Indicates that the RPC system has suffered an error that prevents the session from continuing.\n   * The transport should ideally try to send any queued messages if it can, and then close the\n   * connection. (It's not strictly necessary to deliver queued messages, but the last message sent\n   * before abort() is called is often an \"abort\" message, which communicates the error to the\n   * peer, so if that is dropped, the peer may have less information about what happened.)\n   */\n  abort?(reason: any): void;\n}\n\n// Entry on the exports table.\ntype ExportTableEntry = {\n  hook: StubHook,\n  refcount: number,\n  pull?: Promise<void>\n};\n\n// Entry on the imports table.\nclass ImportTableEntry {\n  constructor(public session: RpcSessionImpl, public importId: number, pulling: boolean) {\n    if (pulling) {\n      this.activePull = Promise.withResolvers<void>();\n    }\n  }\n\n  public localRefcount: number = 0;\n  public remoteRefcount: number = 1;\n\n  private activePull?: PromiseWithResolvers<void>;\n  public resolution?: StubHook;\n\n  // List of integer indexes into session.onBrokenCallbacks which are callbacks registered on\n  // this import. Initialized on first use (so `undefined` is the same as an empty list).\n  private onBrokenRegistrations?: number[];\n\n  resolve(resolution: StubHook) {\n    // TODO: Need embargo handling here? PayloadStubHook needs to be wrapped in a\n    // PromiseStubHook awaiting the embargo I suppose. Previous notes on embargoes:\n    // - Resolve message specifies last call that was received before the resolve. The introducer is\n    //   responsible for any embargoes up to that point.\n    // - Any further calls forwarded by the introducer after that point MUST immediately resolve to\n    //   a forwarded call. The caller is responsible for ensuring the last of these is handed off\n    //   before direct calls can be delivered.\n\n    if (this.localRefcount == 0) {\n      // Already disposed (canceled), so ignore the resolution and don't send a redundant release.\n      resolution.dispose();\n      return;\n    }\n\n    this.resolution = resolution;\n    this.sendRelease();\n\n    if (this.onBrokenRegistrations) {\n      // Delete all our callback registrations from this session and re-register them on the\n      // target stub.\n      for (let i of this.onBrokenRegistrations) {\n        let callback = this.session.onBrokenCallbacks[i];\n        let endIndex = this.session.onBrokenCallbacks.length;\n        resolution.onBroken(callback);\n        if (this.session.onBrokenCallbacks[endIndex] === callback) {\n          // Oh, calling onBroken() just registered the callback back on this connection again.\n          // But when the connection dies, we want all the callbacks to be called in the order in\n          // which they were registered. So we don't want this one pushed to the back of the line\n          // here. So, let's remove the newly-added registration and keep the original.\n          // TODO: This is quite hacky, think about whether this is really the right answer.\n          delete this.session.onBrokenCallbacks[endIndex];\n        } else {\n          // The callback is now registered elsewhere, so delete it from our session.\n          delete this.session.onBrokenCallbacks[i];\n        }\n      }\n      this.onBrokenRegistrations = undefined;\n    }\n\n    if (this.activePull) {\n      this.activePull.resolve();\n      this.activePull = undefined;\n    }\n  }\n\n  async awaitResolution(): Promise<RpcPayload> {\n    if (!this.activePull) {\n      this.session.sendPull(this.importId);\n      this.activePull = Promise.withResolvers<void>();\n    }\n    await this.activePull.promise;\n    return this.resolution!.pull();\n  }\n\n  dispose() {\n    if (this.resolution) {\n      this.resolution.dispose();\n    } else {\n      this.abort(new Error(\"RPC was canceled because the RpcPromise was disposed.\"));\n      this.sendRelease();\n    }\n  }\n\n  abort(error: any) {\n    if (!this.resolution) {\n      this.resolution = new ErrorStubHook(error);\n\n      if (this.activePull) {\n        this.activePull.reject(error);\n        this.activePull = undefined;\n      }\n\n      // The RpcSession itself will have called all our callbacks so we don't need to track the\n      // registrations anymore.\n      this.onBrokenRegistrations = undefined;\n    }\n  }\n\n  onBroken(callback: (error: any) => void): void {\n    if (this.resolution) {\n      this.resolution.onBroken(callback);\n    } else {\n      let index = this.session.onBrokenCallbacks.length;\n      this.session.onBrokenCallbacks.push(callback);\n\n      if (!this.onBrokenRegistrations) this.onBrokenRegistrations = [];\n      this.onBrokenRegistrations.push(index);\n    }\n  }\n\n  private sendRelease() {\n    if (this.remoteRefcount > 0) {\n      this.session.sendRelease(this.importId, this.remoteRefcount);\n      this.remoteRefcount = 0;\n    }\n  }\n};\n\nclass RpcImportHook extends StubHook {\n  public entry?: ImportTableEntry;  // undefined when we're disposed\n\n  // `pulling` is true if we already expect that this import is going to be resolved later, and\n  // null if this import is not allowed to be pulled (i.e. it's a stub not a promise).\n  constructor(public isPromise: boolean, entry: ImportTableEntry) {\n    super();\n    ++entry.localRefcount;\n    this.entry = entry;\n  }\n\n  collectPath(path: PropertyPath): RpcImportHook {\n    return this;\n  }\n\n  getEntry(): ImportTableEntry {\n    if (this.entry) {\n      return this.entry;\n    } else {\n      // Shouldn't get here in practice since the holding stub should have replaced the hook when\n      // disposed.\n      throw new Error(\"This RpcImportHook was already disposed.\");\n    }\n  }\n\n  // -------------------------------------------------------------------------------------\n  // implements StubHook\n\n  call(path: PropertyPath, args: RpcPayload): StubHook {\n    let entry = this.getEntry();\n    if (entry.resolution) {\n      return entry.resolution.call(path, args);\n    } else {\n      return entry.session.sendCall(entry.importId, path, args);\n    }\n  }\n\n  map(path: PropertyPath, captures: StubHook[], instructions: unknown[]): StubHook {\n    let entry: ImportTableEntry;\n    try {\n      entry = this.getEntry();\n    } catch (err) {\n      for (let cap of captures) {\n        cap.dispose();\n      }\n      throw err;\n    }\n\n    if (entry.resolution) {\n      return entry.resolution.map(path, captures, instructions);\n    } else {\n      return entry.session.sendMap(entry.importId, path, captures, instructions);\n    }\n  }\n\n  get(path: PropertyPath): StubHook {\n    let entry = this.getEntry();\n    if (entry.resolution) {\n      return entry.resolution.get(path);\n    } else {\n      return entry.session.sendCall(entry.importId, path);\n    }\n  }\n\n  dup(): RpcImportHook {\n    return new RpcImportHook(false, this.getEntry());\n  }\n\n  pull(): RpcPayload | Promise<RpcPayload> {\n    let entry = this.getEntry();\n\n    if (!this.isPromise) {\n      throw new Error(\"Can't pull this hook because it's not a promise hook.\");\n    }\n\n    if (entry.resolution) {\n      return entry.resolution.pull();\n    }\n\n    return entry.awaitResolution();\n  }\n\n  ignoreUnhandledRejections(): void {\n    // We don't actually have to do anything here because this method only has to ignore rejections\n    // if pull() is *not* called, and if pull() is not called then we won't generate any rejections\n    // anyway.\n  }\n\n  dispose(): void {\n    let entry = this.entry;\n    this.entry = undefined;\n    if (entry) {\n      if (--entry.localRefcount === 0) {\n        entry.dispose();\n      }\n    }\n  }\n\n  onBroken(callback: (error: any) => void): void {\n    if (this.entry) {\n      this.entry.onBroken(callback);\n    }\n  }\n}\n\nclass RpcMainHook extends RpcImportHook {\n  private session?: RpcSessionImpl;\n\n  constructor(entry: ImportTableEntry) {\n    super(false, entry);\n    this.session = entry.session;\n  }\n\n  dispose(): void {\n    if (this.session) {\n      let session = this.session;\n      this.session = undefined;\n      session.shutdown();\n    }\n  }\n}\n\n/**\n * Options to customize behavior of an RPC session. All functions which start a session should\n * optionally accept this.\n */\nexport type RpcSessionOptions = {\n  /**\n   * If provided, this function will be called whenever an `Error` object is serialized (for any\n   * reason, not just because it was thrown). This can be used to log errors, and also to redact\n   * them.\n   *\n   * If `onSendError` returns an Error object, than object will be substituted in place of the\n   * original. If it has a stack property, the stack will be sent to the client.\n   *\n   * If `onSendError` doesn't return anything (or is not provided at all), the default behavior is\n   * to serialize the error with the stack omitted.\n   */\n  onSendError?: (error: Error) => Error | void;\n};\n\nclass RpcSessionImpl implements Importer, Exporter {\n  private exports: Array<ExportTableEntry> = [];\n  private reverseExports: Map<StubHook, ExportId> = new Map();\n  private imports: Array<ImportTableEntry> = [];\n  private abortReason?: any;\n  private cancelReadLoop: (error: any) => void;\n\n  // We assign positive numbers to imports we initiate, and negative numbers to exports we\n  // initiate. So the next import ID is just `imports.length`, but the next export ID needs\n  // to be tracked explicitly.\n  private nextExportId = -1;\n\n  // If set, call this when all incoming calls are complete.\n  private onBatchDone?: Omit<PromiseWithResolvers<void>, \"promise\">;\n\n  // How many promises is our peer expecting us to resolve?\n  private pullCount = 0;\n\n  // Sparse array of onBrokenCallback registrations. Items are strictly appended to the end but\n  // may be deleted from the middle (hence leaving the array sparse).\n  onBrokenCallbacks: ((error: any) => void)[] = [];\n\n  constructor(private transport: RpcTransport, mainHook: StubHook,\n      private options: RpcSessionOptions) {\n    // Export zero is automatically the bootstrap object.\n    this.exports.push({hook: mainHook, refcount: 1});\n\n    // Import zero is the other side's bootstrap object.\n    this.imports.push(new ImportTableEntry(this, 0, false));\n\n    let rejectFunc: (error: any) => void;;\n    let abortPromise = new Promise<never>((resolve, reject) => { rejectFunc = reject; });\n    this.cancelReadLoop = rejectFunc!;\n\n    this.readLoop(abortPromise).catch(err => this.abort(err));\n  }\n\n  // Should only be called once immediately after construction.\n  getMainImport(): RpcImportHook {\n    return new RpcMainHook(this.imports[0]);\n  }\n\n  shutdown(): void {\n    // TODO(someday): Should we add some sort of \"clean shutdown\" mechanism? This gets the job\n    //   done just fine for the moment.\n    this.abort(new Error(\"RPC session was shut down by disposing the main stub\"), false);\n  }\n\n  exportStub(hook: StubHook): ExportId {\n    if (this.abortReason) throw this.abortReason;\n\n    let existingExportId = this.reverseExports.get(hook);\n    if (existingExportId !== undefined) {\n      ++this.exports[existingExportId].refcount;\n      return existingExportId;\n    } else {\n      let exportId = this.nextExportId--;\n      this.exports[exportId] = { hook, refcount: 1 };\n      this.reverseExports.set(hook, exportId);\n      // TODO: Use onBroken().\n      return exportId;\n    }\n  }\n\n  exportPromise(hook: StubHook): ExportId {\n    if (this.abortReason) throw this.abortReason;\n\n    // Promises always use a new ID because otherwise the recipient could miss the resolution.\n    let exportId = this.nextExportId--;\n    this.exports[exportId] = { hook, refcount: 1 };\n    this.reverseExports.set(hook, exportId);\n\n    // Automatically start resolving any promises we send.\n    this.ensureResolvingExport(exportId);\n    return exportId;\n  }\n\n  unexport(ids: Array<ExportId>): void {\n    for (let id of ids) {\n      this.releaseExport(id, 1);\n    }\n  }\n\n  private releaseExport(exportId: ExportId, refcount: number) {\n    let entry = this.exports[exportId];\n    if (!entry) {\n      throw new Error(`no such export ID: ${exportId}`);\n    }\n    if (entry.refcount < refcount) {\n      throw new Error(`refcount would go negative: ${entry.refcount} < ${refcount}`);\n    }\n    entry.refcount -= refcount;\n    if (entry.refcount === 0) {\n      delete this.exports[exportId];\n      this.reverseExports.delete(entry.hook);\n      entry.hook.dispose();\n    }\n  }\n\n  onSendError(error: Error): Error | void {\n    if (this.options.onSendError) {\n      return this.options.onSendError(error);\n    }\n  }\n\n  private ensureResolvingExport(exportId: ExportId) {\n    let exp = this.exports[exportId];\n    if (!exp) {\n      throw new Error(`no such export ID: ${exportId}`);\n    }\n    if (!exp.pull) {\n      let resolve = async () => {\n        let hook = exp.hook;\n        for (;;) {\n          let payload = await hook.pull();\n          if (payload.value instanceof RpcStub) {\n            let {hook: inner, pathIfPromise} = unwrapStubAndPath(payload.value);\n            if (pathIfPromise && pathIfPromise.length == 0) {\n              if (this.getImport(hook) === undefined) {\n                // Optimization: The resolution is just another promise, and it is not a promise\n                // pointing back to the peer. So if we send a resolve message, it's just going to\n                // resolve to another new promise export, which is just going to have to wait for\n                // another resolve message later. This intermediate resolve message gives the peer\n                // no useful information, so let's skip it and just wait for the chained\n                // resolution.\n                hook = inner;\n                continue;\n              }\n            }\n          }\n\n          return payload;\n        }\n      };\n\n      ++this.pullCount;\n      exp.pull = resolve().then(\n        payload => {\n          // We don't transfer ownership of stubs in the payload since the payload\n          // belongs to the hook which sticks around to handle pipelined requests.\n          let value = Devaluator.devaluate(payload.value, undefined, this, payload);\n          this.send([\"resolve\", exportId, value]);\n        },\n        error => {\n          this.send([\"reject\", exportId, Devaluator.devaluate(error, undefined, this)]);\n        }\n      ).catch(\n        error => {\n          // If serialization failed, report the serialization error, which should\n          // itself always be serializable.\n          try {\n            this.send([\"reject\", exportId, Devaluator.devaluate(error, undefined, this)]);\n          } catch (error2) {\n            // TODO: Shouldn't happen, now what?\n            this.abort(error2);\n          }\n        }\n      ).finally(() => {\n        if (--this.pullCount === 0) {\n          if (this.onBatchDone) {\n            this.onBatchDone.resolve();\n          }\n        }\n      });\n    }\n  }\n\n  getImport(hook: StubHook): ImportId | undefined {\n    if (hook instanceof RpcImportHook && hook.entry && hook.entry.session === this) {\n      return hook.entry.importId;\n    } else {\n      return undefined;\n    }\n  }\n\n  importStub(idx: ImportId): RpcImportHook {\n    if (this.abortReason) throw this.abortReason;\n\n    let entry = this.imports[idx];\n    if (!entry) {\n      entry = new ImportTableEntry(this, idx, false);\n      this.imports[idx] = entry;\n    }\n    return new RpcImportHook(/*isPromise=*/false, entry);\n  }\n\n  importPromise(idx: ImportId): StubHook {\n    if (this.abortReason) throw this.abortReason;\n\n    if (this.imports[idx]) {\n      // Can't reuse an existing ID for a promise!\n      return new ErrorStubHook(new Error(\n          \"Bug in RPC system: The peer sent a promise reusing an existing export ID.\"));\n    }\n\n    // Create an already-pulling hook.\n    let entry = new ImportTableEntry(this, idx, true);\n    this.imports[idx] = entry;\n    return new RpcImportHook(/*isPromise=*/true, entry);\n  }\n\n  getExport(idx: ExportId): StubHook | undefined {\n    return this.exports[idx]?.hook;\n  }\n\n  private send(msg: any) {\n    if (this.abortReason !== undefined) {\n      // Ignore sends after we've aborted.\n      return;\n    }\n\n    let msgText: string;\n    try {\n      msgText = JSON.stringify(msg);\n    } catch (err) {\n      // If JSON stringification failed, there's something wrong with the devaluator, as it should\n      // not allow non-JSONable values to be injected in the first place.\n      try { this.abort(err); } catch (err2) {}\n      throw err;\n    }\n\n    this.transport.send(msgText)\n        // If send fails, abort the connection, but don't try to send an abort message since\n        // that'll probably also fail.\n        .catch(err => this.abort(err, false));\n  }\n\n  sendCall(id: ImportId, path: PropertyPath, args?: RpcPayload): RpcImportHook {\n    if (this.abortReason) throw this.abortReason;\n\n    let value: Array<any> = [\"pipeline\", id, path];\n    if (args) {\n      let devalue = Devaluator.devaluate(args.value, undefined, this, args);\n\n      // HACK: Since the args is an array, devaluator will wrap in a second array. Need to unwrap.\n      // TODO: Clean this up somehow.\n      value.push((<Array<unknown>>devalue)[0]);\n\n      // Serializing the payload takes ownership of all stubs within, so the payload itself does\n      // not need to be disposed.\n    }\n    this.send([\"push\", value]);\n\n    let entry = new ImportTableEntry(this, this.imports.length, false);\n    this.imports.push(entry);\n    return new RpcImportHook(/*isPromise=*/true, entry);\n  }\n\n  sendMap(id: ImportId, path: PropertyPath, captures: StubHook[], instructions: unknown[])\n      : RpcImportHook {\n    if (this.abortReason) {\n      for (let cap of captures) {\n        cap.dispose();\n      }\n      throw this.abortReason;\n    }\n\n    let devaluedCaptures = captures.map(hook => {\n      let importId = this.getImport(hook);\n      if (importId !== undefined) {\n        return [\"import\", importId];\n      } else {\n        return [\"export\", this.exportStub(hook)];\n      }\n    });\n\n    let value = [\"remap\", id, path, devaluedCaptures, instructions];\n\n    this.send([\"push\", value]);\n\n    let entry = new ImportTableEntry(this, this.imports.length, false);\n    this.imports.push(entry);\n    return new RpcImportHook(/*isPromise=*/true, entry);\n  }\n\n  sendPull(id: ImportId) {\n    if (this.abortReason) throw this.abortReason;\n\n    this.send([\"pull\", id]);\n  }\n\n  sendRelease(id: ImportId, remoteRefcount: number) {\n    if (this.abortReason) return;\n\n    this.send([\"release\", id, remoteRefcount]);\n    delete this.imports[id];\n  }\n\n  abort(error: any, trySendAbortMessage: boolean = true) {\n    // Don't double-abort.\n    if (this.abortReason !== undefined) return;\n\n    this.cancelReadLoop(error);\n\n    if (trySendAbortMessage) {\n      try {\n        this.transport.send(JSON.stringify([\"abort\", Devaluator\n            .devaluate(error, undefined, this)]))\n            .catch(err => {});\n      } catch (err) {\n        // ignore, probably the whole reason we're aborting is because the transport is broken\n      }\n    }\n\n    if (error === undefined) {\n      // Shouldn't happen, but if it does, avoid setting `abortReason` to `undefined`.\n      error = \"undefined\";\n    }\n\n    this.abortReason = error;\n    if (this.onBatchDone) {\n      this.onBatchDone.reject(error);\n    }\n\n    if (this.transport.abort) {\n      // Call transport's abort handler, but guard against buggy app code.\n      try {\n        this.transport.abort(error);\n      } catch (err) {\n        // Treat as unhandled rejection.\n        Promise.resolve(err);\n      }\n    }\n\n    // WATCH OUT: these are sparse arrays. `for/let/of` will iterate only positive indexes\n    // including deleted indexes -- bad. We need to use `for/let/in` instead.\n    for (let i in this.onBrokenCallbacks) {\n      try {\n        this.onBrokenCallbacks[i](error);\n      } catch (err) {\n        // Treat as unhandled rejection.\n        Promise.resolve(err);\n      }\n    }\n    for (let i in this.imports) {\n      this.imports[i].abort(error);\n    }\n    for (let i in this.exports) {\n      this.exports[i].hook.dispose();\n    }\n  }\n\n  private async readLoop(abortPromise: Promise<never>) {\n    while (!this.abortReason) {\n      let msg = JSON.parse(await Promise.race([this.transport.receive(), abortPromise]));\n      if (this.abortReason) break;  // check again before processing\n\n      if (msg instanceof Array) {\n        switch (msg[0]) {\n          case \"push\":  // [\"push\", Expression]\n            if (msg.length > 1) {\n              let payload = new Evaluator(this).evaluate(msg[1]);\n              let hook = new PayloadStubHook(payload);\n\n              // It's possible for a rejection to occur before the client gets a chance to send\n              // a \"pull\" message or to use the promise in a pipeline. We don't want that to be\n              // treated as an unhandled rejection on our end.\n              hook.ignoreUnhandledRejections();\n\n              this.exports.push({ hook, refcount: 1 });\n              continue;\n            }\n            break;\n\n          case \"pull\": {  // [\"pull\", ImportId]\n            let exportId = msg[1];\n            if (typeof exportId == \"number\") {\n              this.ensureResolvingExport(exportId);\n              continue;\n            }\n            break;\n          }\n\n          case \"resolve\":   // [\"resolve\", ExportId, Expression]\n          case \"reject\": {  // [\"reject\", ExportId, Expression]\n            let importId = msg[1];\n            if (typeof importId == \"number\" && msg.length > 2) {\n              let imp = this.imports[importId];\n              if (imp) {\n                if (msg[0] == \"resolve\") {\n                  imp.resolve(new PayloadStubHook(new Evaluator(this).evaluate(msg[2])));\n                } else {\n                  // HACK: We expect errors are always simple values (no stubs) so we can just\n                  //   pull the value out of the payload.\n                  let payload = new Evaluator(this).evaluate(msg[2]);\n                  payload.dispose();  // just in case -- should be no-op\n                  imp.resolve(new ErrorStubHook(payload.value));\n                }\n              } else {\n                // Import ID is not found on the table. Probably we released it already, in which\n                // case we do not care about the resolution, so whatever.\n\n                if (msg[0] == \"resolve\") {\n                  // We need to evaluate the resolution and immediately dispose it so that we\n                  // release any stubs it contains.\n                  new Evaluator(this).evaluate(msg[2]).dispose();\n                }\n              }\n              continue;\n            }\n            break;\n          }\n\n          case \"release\": {\n            let exportId = msg[1];\n            let refcount = msg[2];\n            if (typeof exportId == \"number\" && typeof refcount == \"number\") {\n              this.releaseExport(exportId, refcount);\n              continue;\n            }\n            break;\n          }\n\n          case \"abort\": {\n            let payload = new Evaluator(this).evaluate(msg[1]);\n            payload.dispose();  // just in case -- should be no-op\n            this.abort(payload, false);\n            break;\n          }\n        }\n      }\n\n      throw new Error(`bad RPC message: ${JSON.stringify(msg)}`);\n    }\n  }\n\n  async drain(): Promise<void> {\n    if (this.abortReason) {\n      throw this.abortReason;\n    }\n\n    if (this.pullCount > 0) {\n      let {promise, resolve, reject} = Promise.withResolvers<void>();\n      this.onBatchDone = {resolve, reject};\n      await promise;\n    }\n  }\n\n  getStats(): {imports: number, exports: number} {\n    let result = {imports: 0, exports: 0};\n    // We can't just use `.length` because the arrays can be sparse and can have negative indexes.\n    for (let i in this.imports) {\n      ++result.imports;\n    }\n    for (let i in this.exports) {\n      ++result.exports;\n    }\n    return result;\n  }\n}\n\n// Public interface that wraps RpcSession and hides private implementation details (even from\n// JavaScript with no type enforcement).\nexport class RpcSession {\n  #session: RpcSessionImpl;\n  #mainStub: RpcStub;\n\n  constructor(transport: RpcTransport, localMain?: any, options: RpcSessionOptions = {}) {\n    let mainHook: StubHook;\n    if (localMain) {\n      mainHook = new PayloadStubHook(RpcPayload.fromAppReturn(localMain));\n    } else {\n      mainHook = new ErrorStubHook(new Error(\"This connection has no main object.\"));\n    }\n    this.#session = new RpcSessionImpl(transport, mainHook, options);\n    this.#mainStub = new RpcStub(this.#session.getMainImport());\n  }\n\n  getRemoteMain(): RpcStub {\n    return this.#mainStub;\n  }\n\n  getStats(): {imports: number, exports: number} {\n    return this.#session.getStats();\n  }\n\n  drain(): Promise<void> {\n    return this.#session.drain();\n  }\n}\n","// Copyright (c) 2025 Cloudflare, Inc.\n// Licensed under the MIT license found in the LICENSE.txt file or at:\n//     https://opensource.org/license/mit\n\n/// <reference types=\"@cloudflare/workers-types\" />\n\nimport { RpcStub } from \"./core.js\";\nimport { RpcTransport, RpcSession, RpcSessionOptions } from \"./rpc.js\";\n\nexport function newWebSocketRpcSession(\n    webSocket: WebSocket | string, localMain?: any, options?: RpcSessionOptions): RpcStub {\n  if (typeof webSocket === \"string\") {\n    webSocket = new WebSocket(webSocket);\n  }\n\n  let transport = new WebSocketTransport(webSocket);\n  let rpc = new RpcSession(transport, localMain, options);\n  return rpc.getRemoteMain();\n}\n\n/**\n * For use in Cloudflare Workers: Construct an HTTP response that starts a WebSocket RPC session\n * with the given `localMain`.\n */\nexport function newWorkersWebSocketRpcResponse(\n    request: Request, localMain?: any, options?: RpcSessionOptions): Response {\n  if (request.headers.get(\"Upgrade\")?.toLowerCase() !== \"websocket\") {\n    return new Response(\"This endpoint only accepts WebSocket requests.\", { status: 400 });\n  }\n\n  let pair = new WebSocketPair();\n  let server = pair[0];\n  server.accept()\n  newWebSocketRpcSession(server, localMain, options);\n  return new Response(null, {\n    status: 101,\n    webSocket: pair[1],\n  });\n}\n\nclass WebSocketTransport implements RpcTransport {\n  constructor (webSocket: WebSocket) {\n    this.#webSocket = webSocket;\n\n    if (webSocket.readyState === WebSocket.CONNECTING) {\n      this.#sendQueue = [];\n      webSocket.addEventListener(\"open\", event => {\n        try {\n          for (let message of this.#sendQueue!) {\n            webSocket.send(message);\n          }\n        } catch (err) {\n          this.#receivedError(err);\n        }\n        this.#sendQueue = undefined;\n      });\n    }\n\n    webSocket.addEventListener(\"message\", (event: MessageEvent<any>) => {\n      if (this.#error) {\n        // Ignore further messages.\n      } else if (typeof event.data === \"string\") {\n        if (this.#receiveResolver) {\n          this.#receiveResolver(event.data);\n          this.#receiveResolver = undefined;\n          this.#receiveRejecter = undefined;\n        } else {\n          this.#receiveQueue.push(event.data);\n        }\n      } else {\n        this.#receivedError(new TypeError(\"Received non-string message from WebSocket.\"));\n      }\n    });\n\n    webSocket.addEventListener(\"close\", (event: CloseEvent) => {\n      this.#receivedError(new Error(`Peer closed WebSocket: ${event.code} ${event.reason}`));\n    });\n\n    webSocket.addEventListener(\"error\", (event: Event) => {\n      this.#receivedError(new Error(`WebSocket connection failed.`));\n    });\n  }\n\n  #webSocket: WebSocket;\n  #sendQueue?: string[];  // only if not opened yet\n  #receiveResolver?: (message: string) => void;\n  #receiveRejecter?: (err: any) => void;\n  #receiveQueue: string[] = [];\n  #error?: any;\n\n  async send(message: string): Promise<void> {\n    if (this.#sendQueue === undefined) {\n      this.#webSocket.send(message);\n    } else {\n      // Not open yet, queue for later.\n      this.#sendQueue.push(message);\n    }\n  }\n\n  async receive(): Promise<string> {\n    if (this.#receiveQueue.length > 0) {\n      return this.#receiveQueue.shift()!;\n    } else if (this.#error) {\n      throw this.#error;\n    } else {\n      return new Promise<string>((resolve, reject) => {\n        this.#receiveResolver = resolve;\n        this.#receiveRejecter = reject;\n      });\n    }\n  }\n\n  abort?(reason: any): void {\n    let message: string;\n    if (reason instanceof Error) {\n      message = reason.message;\n    } else {\n      message = `${reason}`;\n    }\n    this.#webSocket.close(3000, message);\n\n    if (!this.#error) {\n      this.#error = reason;\n      // No need to call receiveRejecter(); RPC implementation will stop listening anyway.\n    }\n  }\n\n  #receivedError(reason: any) {\n    if (!this.#error) {\n      this.#error = reason;\n      if (this.#receiveRejecter) {\n        this.#receiveRejecter(reason);\n        this.#receiveResolver = undefined;\n        this.#receiveRejecter = undefined;\n      }\n    }\n  }\n}\n","// Copyright (c) 2025 Cloudflare, Inc.\n// Licensed under the MIT license found in the LICENSE.txt file or at:\n//     https://opensource.org/license/mit\n\nimport { RpcStub } from \"./core.js\";\nimport { RpcTransport, RpcSession, RpcSessionOptions } from \"./rpc.js\";\nimport type { IncomingMessage, ServerResponse, OutgoingHttpHeader, OutgoingHttpHeaders } from \"node:http\";\n\ntype SendBatchFunc = (batch: string[]) => Promise<string[]>;\n\nclass BatchClientTransport implements RpcTransport {\n  constructor(sendBatch: SendBatchFunc) {\n    this.#promise = this.#scheduleBatch(sendBatch);\n  }\n\n  #promise: Promise<void>;\n  #aborted: any;\n\n  #batchToSend: string[] | null = [];\n  #batchToReceive: string[] | null = null;\n\n  async send(message: string): Promise<void> {\n    // If the batch was already sent, we just ignore the message, because throwing may cause the\n    // RPC system to abort prematurely. Once the last receive() is done then we'll throw an error\n    // that aborts the RPC system at the right time and will propagate to all other requests.\n    if (this.#batchToSend !== null) {\n      this.#batchToSend.push(message);\n    }\n  }\n\n  async receive(): Promise<string> {\n    if (!this.#batchToReceive) {\n      await this.#promise;\n    }\n\n    let msg = this.#batchToReceive!.shift();\n    if (msg !== undefined) {\n      return msg;\n    } else {\n      // No more messages. An error thrown here will propagate out of any calls that are still\n      // open.\n      throw new Error(\"Batch RPC request ended.\");\n    }\n  }\n\n  abort?(reason: any): void {\n    this.#aborted = reason;\n  }\n\n  async #scheduleBatch(sendBatch: SendBatchFunc) {\n    // Wait for microtask queue to clear before sending a batch.\n    //\n    // Note that simply waiting for one turn of the microtask queue (await Promise.resolve()) is\n    // not good enough here as the application needs a chance to call `.then()` on every RPC\n    // promise in order to explicitly indicate they want the results. Unfortunately, `await`ing\n    // a thenable does not call `.then()` immediately -- for some reason it waits for a turn of\n    // the microtask queue first, *then* calls `.then()`.\n    await new Promise(resolve => setTimeout(resolve, 0));\n\n    if (this.#aborted !== undefined) {\n      throw this.#aborted;\n    }\n\n    let batch = this.#batchToSend!;\n    this.#batchToSend = null;\n    this.#batchToReceive = await sendBatch(batch);\n  }\n}\n\nexport function newHttpBatchRpcSession(\n    urlOrRequest: string | Request, options?: RpcSessionOptions): RpcStub {\n  let sendBatch: SendBatchFunc = async (batch: string[]) => {\n    let response = await fetch(urlOrRequest, {\n      method: \"POST\",\n      body: batch.join(\"\\n\"),\n    });\n\n    if (!response.ok) {\n      response.body?.cancel();\n      throw new Error(`RPC request failed: ${response.status} ${response.statusText}`);\n    }\n\n    let body = await response.text();\n    return body == \"\" ? [] : body.split(\"\\n\");\n  };\n\n  let transport = new BatchClientTransport(sendBatch);\n  let rpc = new RpcSession(transport, undefined, options);\n  return rpc.getRemoteMain();\n}\n\nclass BatchServerTransport implements RpcTransport {\n  constructor(batch: string[]) {\n    this.#batchToReceive = batch;\n  }\n\n  #batchToSend: string[] = [];\n  #batchToReceive: string[];\n  #allReceived: PromiseWithResolvers<void> = Promise.withResolvers<void>();\n\n  async send(message: string): Promise<void> {\n    this.#batchToSend.push(message);\n  }\n\n  async receive(): Promise<string> {\n    let msg = this.#batchToReceive!.shift();\n    if (msg !== undefined) {\n      return msg;\n    } else {\n      // No more messages.\n      this.#allReceived.resolve();\n      return new Promise(r => {});\n    }\n  }\n\n  abort?(reason: any): void {\n    this.#allReceived.reject(reason);\n  }\n\n  whenAllReceived() {\n    return this.#allReceived.promise;\n  }\n\n  getResponseBody(): string {\n    return this.#batchToSend.join(\"\\n\");\n  }\n}\n\n/**\n * Implements the server end of an HTTP batch session, using standard Fetch API types to represent\n * HTTP requests and responses.\n *\n * @param request The request received from the client initiating the session.\n * @param localMain The main stub or RpcTarget which the server wishes to expose to the client.\n * @param options Optional RPC session options.\n * @returns The HTTP response to return to the client. Note that the returned object has mutable\n *     headers, so you can modify them using e.g. `response.headers.set(\"Foo\", \"bar\")`.\n */\nexport async function newHttpBatchRpcResponse(\n    request: Request, localMain: any, options?: RpcSessionOptions): Promise<Response> {\n  if (request.method !== \"POST\") {\n    return new Response(\"This endpoint only accepts POST requests.\", { status: 405 });\n  }\n\n  let body = await request.text();\n  let batch = body === \"\" ? [] : body.split(\"\\n\");\n\n  let transport = new BatchServerTransport(batch);\n  let rpc = new RpcSession(transport, localMain, options);\n\n  // TODO: Arguably we should arrange so any attempts to pull promise resolutions from the client\n  //   will reject rather than just hang. But it IS valid to make server->client calls in order to\n  //   then pipeline the result into something returned to the client. We don't want the errors to\n  //   prematurely cancel anything that would eventually complete. So for now we just say, it's the\n  //   app's responsibility to not wait on any server -> client calls since they will never\n  //   complete.\n\n  await transport.whenAllReceived();\n  await rpc.drain();\n\n  // TODO: Ask RpcSession to dispose everything it is still holding on to?\n\n  return new Response(transport.getResponseBody());\n}\n\n/**\n * Implements the server end of an HTTP batch session using traditional Node.js HTTP APIs.\n *\n * @param request The request received from the client initiating the session.\n * @param response The response object, to which the response should be written.\n * @param localMain The main stub or RpcTarget which the server wishes to expose to the client.\n * @param options Optional RPC session options. You can also pass headers to set on the response.\n */\nexport async function nodeHttpBatchRpcResponse(\n    request: IncomingMessage, response: ServerResponse,\n    localMain: any,\n    options?: RpcSessionOptions & {\n      headers?: OutgoingHttpHeaders | OutgoingHttpHeader[],\n    }): Promise<void> {\n  if (request.method !== \"POST\") {\n    response.writeHead(405, \"This endpoint only accepts POST requests.\");\n  }\n\n  let body = await new Promise<string>((resolve, reject) => {\n    let chunks: Buffer[] = [];\n    request.on(\"data\", chunk => {\n      chunks.push(chunk);\n    });\n    request.on(\"end\", () => {\n      resolve(Buffer.concat(chunks).toString());\n    });\n    request.on(\"error\", reject);\n  });\n  let batch = body === \"\" ? [] : body.split(\"\\n\");\n\n  let transport = new BatchServerTransport(batch);\n  let rpc = new RpcSession(transport, localMain, options);\n\n  await transport.whenAllReceived();\n  await rpc.drain();\n\n  response.writeHead(200, options?.headers);\n  response.end(transport.getResponseBody());\n}\n","// Copyright (c) 2025 Cloudflare, Inc.\n// Licensed under the MIT license found in the LICENSE.txt file or at:\n//     https://opensource.org/license/mit\n\nimport { RpcStub } from \"./core.js\";\nimport { RpcTransport, RpcSession, RpcSessionOptions } from \"./rpc.js\";\n\n// Start a MessagePort session given a MessagePort or a pair of MessagePorts.\n//\n// `localMain` is the main RPC interface to expose to the peer. Returns a stub for the main\n// interface exposed from the peer.\nexport function newMessagePortRpcSession(\n    port: MessagePort, localMain?: any, options?: RpcSessionOptions): RpcStub {\n  let transport = new MessagePortTransport(port);\n  let rpc = new RpcSession(transport, localMain, options);\n  return rpc.getRemoteMain();\n}\n\nclass MessagePortTransport implements RpcTransport {\n  constructor (port: MessagePort) {\n    this.#port = port;\n\n    // Start listening for messages\n    port.start();\n\n    port.addEventListener(\"message\", (event: MessageEvent<any>) => {\n      if (this.#error) {\n        // Ignore further messages.\n      } else if (event.data === null) {\n        // Peer is signaling that they're closing the connection\n        this.#receivedError(new Error(\"Peer closed MessagePort connection.\"));\n      } else if (typeof event.data === \"string\") {\n        if (this.#receiveResolver) {\n          this.#receiveResolver(event.data);\n          this.#receiveResolver = undefined;\n          this.#receiveRejecter = undefined;\n        } else {\n          this.#receiveQueue.push(event.data);\n        }\n      } else {\n        this.#receivedError(new TypeError(\"Received non-string message from MessagePort.\"));\n      }\n    });\n\n    port.addEventListener(\"messageerror\", (event: MessageEvent) => {\n      this.#receivedError(new Error(\"MessagePort message error.\"));\n    });\n  }\n\n  #port: MessagePort;\n  #receiveResolver?: (message: string) => void;\n  #receiveRejecter?: (err: any) => void;\n  #receiveQueue: string[] = [];\n  #error?: any;\n\n  async send(message: string): Promise<void> {\n    if (this.#error) {\n      throw this.#error;\n    }\n    this.#port.postMessage(message);\n  }\n\n  async receive(): Promise<string> {\n    if (this.#receiveQueue.length > 0) {\n      return this.#receiveQueue.shift()!;\n    } else if (this.#error) {\n      throw this.#error;\n    } else {\n      return new Promise<string>((resolve, reject) => {\n        this.#receiveResolver = resolve;\n        this.#receiveRejecter = reject;\n      });\n    }\n  }\n\n  abort?(reason: any): void {\n    // Send close signal to peer before closing\n    try {\n      this.#port.postMessage(null);\n    } catch (err) {\n      // Ignore errors when sending close signal - port might already be closed\n    }\n\n    this.#port.close();\n\n    if (!this.#error) {\n      this.#error = reason;\n      // No need to call receiveRejecter(); RPC implementation will stop listening anyway.\n    }\n  }\n\n  #receivedError(reason: any) {\n    if (!this.#error) {\n      this.#error = reason;\n      if (this.#receiveRejecter) {\n        this.#receiveRejecter(reason);\n        this.#receiveResolver = undefined;\n        this.#receiveRejecter = undefined;\n      }\n    }\n  }\n}","// Copyright (c) 2025 Cloudflare, Inc.\n// Licensed under the MIT license found in the LICENSE.txt file or at:\n//     https://opensource.org/license/mit\n\nimport { StubHook, PropertyPath, RpcPayload, RpcStub, RpcPromise, withCallInterceptor, ErrorStubHook, mapImpl, PayloadStubHook, unwrapStubAndPath, unwrapStubNoProperties } from \"./core.js\";\nimport { Devaluator, Exporter, Importer, ExportId, ImportId, Evaluator } from \"./serialize.js\";\n\nlet currentMapBuilder: MapBuilder | undefined;\n\n// We use this type signature when building the instructions for type checking purposes. It\n// describes a subset of the overall RPC protocol.\nexport type MapInstruction =\n    | [\"pipeline\", number, PropertyPath]\n    | [\"pipeline\", number, PropertyPath, unknown]\n    | [\"remap\", number, PropertyPath, [\"import\", number][], MapInstruction[]]\n\nclass MapBuilder implements Exporter {\n  private context:\n    | {parent: undefined, captures: StubHook[], subject: StubHook, path: PropertyPath}\n    | {parent: MapBuilder, captures: number[], subject: number, path: PropertyPath};\n  private captureMap: Map<StubHook, number> = new Map();\n\n  private instructions: MapInstruction[] = [];\n\n  constructor(subject: StubHook, path: PropertyPath) {\n    if (currentMapBuilder) {\n      this.context = {\n        parent: currentMapBuilder,\n        captures: [],\n        subject: currentMapBuilder.capture(subject),\n        path\n      };\n    } else {\n      this.context = {\n        parent: undefined,\n        captures: [],\n        subject,\n        path\n      };\n    }\n\n    currentMapBuilder = this;\n  }\n\n  unregister() {\n    currentMapBuilder = this.context.parent;\n  }\n\n  makeInput(): MapVariableHook {\n    return new MapVariableHook(this, 0);\n  }\n\n  makeOutput(result: RpcPayload): StubHook {\n    let devalued: unknown;\n    try {\n      devalued = Devaluator.devaluate(result.value, undefined, this, result);\n    } finally {\n      result.dispose();\n    }\n\n    // The result is the final instruction. This doesn't actually fit our MapInstruction type\n    // signature, so we cheat a bit.\n    this.instructions.push(<any>devalued);\n\n    if (this.context.parent) {\n      this.context.parent.instructions.push(\n        [\"remap\", this.context.subject, this.context.path,\n                  this.context.captures.map(cap => [\"import\", cap]),\n                  this.instructions]\n      );\n      return new MapVariableHook(this.context.parent, this.context.parent.instructions.length);\n    } else {\n      return this.context.subject.map(this.context.path, this.context.captures, this.instructions);\n    }\n  }\n\n  pushCall(hook: StubHook, path: PropertyPath, params: RpcPayload): StubHook {\n    let devalued = Devaluator.devaluate(params.value, undefined, this, params);\n    // HACK: Since the args is an array, devaluator will wrap in a second array. Need to unwrap.\n    // TODO: Clean this up somehow.\n    devalued = (<Array<unknown>>devalued)[0];\n\n    let subject = this.capture(hook.dup());\n    this.instructions.push([\"pipeline\", subject, path, devalued]);\n    return new MapVariableHook(this, this.instructions.length);\n  }\n\n  pushGet(hook: StubHook, path: PropertyPath): StubHook {\n    let subject = this.capture(hook.dup());\n    this.instructions.push([\"pipeline\", subject, path]);\n    return new MapVariableHook(this, this.instructions.length);\n  }\n\n  capture(hook: StubHook): number {\n    if (hook instanceof MapVariableHook && hook.mapper === this) {\n      // Oh, this is already our own hook.\n      return hook.idx;\n    }\n\n    // TODO: Well, the hooks passed in are always unique, so they'll never exist in captureMap.\n    //   I suppose this is a problem with RPC as well. We need a way to identify hooks that are\n    //   dupes of the same target.\n    let result = this.captureMap.get(hook);\n    if (result === undefined) {\n      if (this.context.parent) {\n        let parentIdx = this.context.parent.capture(hook);\n        this.context.captures.push(parentIdx);\n      } else {\n        this.context.captures.push(hook);\n      }\n      result = -this.context.captures.length;\n      this.captureMap.set(hook, result);\n    }\n    return result;\n  }\n\n  // ---------------------------------------------------------------------------\n  // implements Exporter\n\n  exportStub(hook: StubHook): ExportId {\n    // It appears someone did something like:\n    //\n    //     stub.map(x => { return x.doSomething(new MyRpcTarget()); })\n    //\n    // That... won't work. They need to do this instead:\n    //\n    //     using myTargetStub = new RpcStub(new MyRpcTarget());\n    //     stub.map(x => { return x.doSomething(myTargetStub.dup()); })\n    //\n    // TODO(someday): Consider carefully if the inline syntax is maybe OK. If so, perhaps the\n    //   serializer could try calling `getImport()` even for known-local hooks.\n    // TODO(someday): Do we need to support rpc-thenable somehow?\n    throw new Error(\n        \"Can't construct an RpcTarget or RPC callback inside a mapper function. Try creating a \" +\n        \"new RpcStub outside the callback first, then using it inside the callback.\");\n  }\n  exportPromise(hook: StubHook): ExportId {\n    return this.exportStub(hook);\n  }\n  getImport(hook: StubHook): ImportId | undefined {\n    return this.capture(hook);\n  }\n\n  unexport(ids: Array<ExportId>): void {\n    // Presumably this MapBuilder is cooked anyway, so we don't really have to release anything.\n  }\n\n  onSendError(error: Error): Error | void {\n    // TODO(someday): Can we use the error-sender hook from the RPC system somehow?\n  }\n};\n\nmapImpl.sendMap = (hook: StubHook, path: PropertyPath, func: (promise: RpcPromise) => unknown) => {\n  let builder = new MapBuilder(hook, path);\n  let result: RpcPayload;\n  try {\n    result = RpcPayload.fromAppReturn(withCallInterceptor(builder.pushCall.bind(builder), () => {\n      return func(new RpcPromise(builder.makeInput(), []));\n    }));\n  } finally {\n    builder.unregister();\n  }\n\n  // Detect misuse: Map callbacks cannot be async.\n  if (result instanceof Promise) {\n    // Squelch unhandled rejections from the map function itself -- it'll probably just throw\n    // something about pulling a MapVariableHook.\n    result.catch(err => {});\n\n    // Throw an understandable error.\n    throw new Error(\"RPC map() callbacks cannot be async.\");\n  }\n\n  return new RpcPromise(builder.makeOutput(result), []);\n}\n\nfunction throwMapperBuilderUseError(): never {\n  throw new Error(\n      \"Attempted to use an abstract placeholder from a mapper function. Please make sure your \" +\n      \"map function has no side effects.\");\n}\n\n// StubHook which represents a variable in a map function.\nclass MapVariableHook extends StubHook {\n  constructor(public mapper: MapBuilder, public idx: number) {\n    super();\n  }\n\n  // We don't have anything we actually need to dispose, so dup() can just return the same hook.\n  dup(): StubHook { return this; }\n  dispose(): void {}\n\n  get(path: PropertyPath): StubHook {\n    // This can actually be invoked as part of serialization, so we'll need to support it.\n    if (path.length == 0) {\n      // Since this hook cannot be pulled anyway, and dispose() is a no-op, we can actually just\n      // return the same hook again to represent getting the empty path.\n      return this;\n    } else if (currentMapBuilder) {\n      return currentMapBuilder.pushGet(this, path);\n    } else {\n      throwMapperBuilderUseError();\n    }\n  }\n\n  // Other methods should never be called.\n  call(path: PropertyPath, args: RpcPayload): StubHook {\n    // Can't be called; all calls are intercepted.\n    throwMapperBuilderUseError();\n  }\n\n  map(path: PropertyPath, captures: StubHook[], instructions: unknown[]): StubHook {\n    // Can't be called; all map()s are intercepted.\n    throwMapperBuilderUseError();\n  }\n\n  pull(): RpcPayload | Promise<RpcPayload> {\n    // Map functions cannot await.\n    throwMapperBuilderUseError();\n  }\n\n  ignoreUnhandledRejections(): void {\n    // Probably never called but whatever.\n  }\n\n  onBroken(callback: (error: any) => void): void {\n    throwMapperBuilderUseError();\n  }\n}\n\n// =======================================================================================\n\nclass MapApplicator implements Importer {\n  private variables: StubHook[];\n\n  constructor(private captures: StubHook[], input: StubHook) {\n    this.variables = [input];\n  }\n\n  dispose() {\n    for (let variable of this.variables) {\n      variable.dispose();\n    }\n  }\n\n  apply(instructions: unknown[]): RpcPayload {\n    try {\n      if (instructions.length < 1) {\n        throw new Error(\"Invalid empty mapper function.\");\n      }\n\n      for (let instruction of instructions.slice(0, -1)) {\n        let payload = new Evaluator(this).evaluateCopy(instruction);\n\n        // The payload almost always contains a single stub. As an optimization, unwrap it.\n        if (payload.value instanceof RpcStub) {\n          let hook = unwrapStubNoProperties(payload.value);\n          if (hook) {\n            this.variables.push(hook);\n            continue;\n          }\n        }\n\n        this.variables.push(new PayloadStubHook(payload));\n      }\n\n      return new Evaluator(this).evaluateCopy(instructions[instructions.length - 1]);\n    } finally {\n      for (let variable of this.variables) {\n        variable.dispose();\n      }\n    }\n  }\n\n  importStub(idx: ImportId): StubHook {\n    // This implies we saw an \"export\" appear inside the body of a mapper function. This should be\n    // impossible because exportStub()/exportPromise() throw exceptions in MapBuilder.\n    throw new Error(\"A mapper function cannot refer to exports.\");\n  }\n  importPromise(idx: ImportId): StubHook {\n    return this.importStub(idx);\n  }\n\n  getExport(idx: ExportId): StubHook | undefined {\n    if (idx < 0) {\n      return this.captures[-idx - 1];\n    } else {\n      return this.variables[idx];\n    }\n  }\n}\n\nfunction applyMapToElement(input: unknown, parent: object | undefined, owner: RpcPayload | null,\n                           captures: StubHook[], instructions: unknown[]): RpcPayload {\n  // TODO(perf): I wonder if we could use .fromAppParams() instead of .deepCopyFrom()? It\n  //   maybe wouldn't correctly handle the case of RpcTargets in the input, so we need a variant\n  //   which takes an `owner`, which does add some complexity.\n  let inputHook = new PayloadStubHook(RpcPayload.deepCopyFrom(input, parent, owner));\n  let mapper = new MapApplicator(captures, inputHook);\n  try {\n    return mapper.apply(instructions);\n  } finally {\n    mapper.dispose();\n  }\n}\n\nmapImpl.applyMap = (input: unknown, parent: object | undefined, owner: RpcPayload | null,\n                    captures: StubHook[], instructions: unknown[]) => {\n  try {\n    let result: RpcPayload;\n    if (input instanceof RpcPromise) {\n      // The caller is responsible for making sure the input is not a promise, since we can't\n      // then know if it would resolve to an array later.\n      throw new Error(\"applyMap() can't be called on RpcPromise\");\n    } else if (input instanceof Array) {\n      let payloads: RpcPayload[] = [];\n      try {\n        for (let elem of input) {\n          payloads.push(applyMapToElement(elem, input, owner, captures, instructions));\n        }\n      } catch (err) {\n        for (let payload of payloads) {\n          payload.dispose();\n        }\n        throw err;\n      }\n\n      result = RpcPayload.fromArray(payloads);\n    } else if (input === null || input === undefined) {\n      result = RpcPayload.fromAppReturn(input);\n    } else {\n      result = applyMapToElement(input, parent, owner, captures, instructions);\n    }\n\n    // TODO(perf): We should probably return a hook that allows pipelining but whose pull() doesn't\n    //   resolve until all promises in the payload have been substituted.\n    return new PayloadStubHook(result);\n  } finally {\n    for (let cap of captures) {\n      cap.dispose();\n    }\n  }\n}\n\nexport function forceInitMap() {}\n","// Copyright (c) 2025 Cloudflare, Inc.\n// Licensed under the MIT license found in the LICENSE.txt file or at:\n//     https://opensource.org/license/mit\n\nimport { RpcTarget as RpcTargetImpl, RpcStub as RpcStubImpl, RpcPromise as RpcPromiseImpl } from \"./core.js\";\nimport { serialize, deserialize } from \"./serialize.js\";\nimport { RpcTransport, RpcSession as RpcSessionImpl, RpcSessionOptions } from \"./rpc.js\";\nimport { RpcTargetBranded, RpcCompatible, Stub, Stubify, __RPC_TARGET_BRAND } from \"./types.js\";\nimport { newWebSocketRpcSession as newWebSocketRpcSessionImpl,\n         newWorkersWebSocketRpcResponse } from \"./websocket.js\";\nimport { newHttpBatchRpcSession as newHttpBatchRpcSessionImpl,\n         newHttpBatchRpcResponse, nodeHttpBatchRpcResponse } from \"./batch.js\";\nimport { newMessagePortRpcSession as newMessagePortRpcSessionImpl } from \"./messageport.js\";\nimport { forceInitMap } from \"./map.js\";\n\nforceInitMap();\n\n// Re-export public API types.\nexport { serialize, deserialize, newWorkersWebSocketRpcResponse, newHttpBatchRpcResponse,\n         nodeHttpBatchRpcResponse };\nexport type { RpcTransport, RpcSessionOptions, RpcCompatible };\n\n// Hack the type system to make RpcStub's types work nicely!\n/**\n * Represents a reference to a remote object, on which methods may be remotely invoked via RPC.\n *\n * `RpcStub` can represent any interface (when using TypeScript, you pass the specific interface\n * type as `T`, but this isn't known at runtime). The way this works is, `RpcStub` is actually a\n * `Proxy`. It makes itself appear as if every possible method / property name is defined. You can\n * invoke any method name, and the invocation will be sent to the server. If it turns out that no\n * such method exists on the remote object, an exception is thrown back. But the client does not\n * actually know, until that point, what methods exist.\n */\nexport type RpcStub<T extends RpcCompatible<T>> = Stub<T>;\nexport const RpcStub: {\n  new <T extends RpcCompatible<T>>(value: T): RpcStub<T>;\n} = <any>RpcStubImpl;\n\n/**\n * Represents the result of an RPC call.\n *\n * Also used to represent properties. That is, `stub.foo` evaluates to an `RpcPromise` for the\n * value of `foo`.\n *\n * This isn't actually a JavaScript `Promise`. It does, however, have `then()`, `catch()`, and\n * `finally()` methods, like `Promise` does, and because it has a `then()` method, JavaScript will\n * allow you to treat it like a promise, e.g. you can `await` it.\n *\n * An `RpcPromise` is also a proxy, just like `RpcStub`, where calling methods or awaiting\n * properties will make a pipelined network request.\n *\n * Note that and `RpcPromise` is \"lazy\": the actual final result is not requested from the server\n * until you actually `await` the promise (or call `then()`, etc. on it). This is an optimization:\n * if you only intend to use the promise for pipelining and you never await it, then there's no\n * need to transmit the resolution!\n */\nexport type RpcPromise<T extends RpcCompatible<T>> = Stub<T> & Promise<Stubify<T>>;\nexport const RpcPromise: {\n  // Note: Cannot construct directly!\n} = <any>RpcPromiseImpl;\n\n/**\n * Use to construct an `RpcSession` on top of a custom `RpcTransport`.\n *\n * Most people won't use this. You only need it if you've implemented your own `RpcTransport`.\n */\nexport interface RpcSession<T extends RpcCompatible<T> = undefined> {\n  getRemoteMain(): RpcStub<T>;\n  getStats(): {imports: number, exports: number};\n\n  // Waits until the peer is not waiting on any more promise resolutions from us. This is useful\n  // in particular to decide when a batch is complete.\n  drain(): Promise<void>;\n}\nexport const RpcSession: {\n  new <T extends RpcCompatible<T> = undefined>(\n      transport: RpcTransport, localMain?: any, options?: RpcSessionOptions): RpcSession<T>;\n} = <any>RpcSessionImpl;\n\n// RpcTarget needs some hackage too to brand it properly and account for the implementation\n// conditionally being imported from \"cloudflare:workers\".\n/**\n * Classes which are intended to be passed by reference and called over RPC must extend\n * `RpcTarget`. A class which does not extend `RpcTarget` (and which doesn't have built-in support\n * from the RPC system) cannot be passed in an RPC message at all; an exception will be thrown.\n *\n * Note that on Cloudflare Workers, this `RpcTarget` is an alias for the one exported from the\n * \"cloudflare:workers\" module, so they can be used interchangably.\n */\nexport interface RpcTarget extends RpcTargetBranded {};\nexport const RpcTarget: {\n  new(): RpcTarget;\n} = RpcTargetImpl;\n\n/**\n * Empty interface used as default type parameter for sessions where the other side doesn't\n * necessarily export a main interface.\n */\ninterface Empty {}\n\n/**\n * Start a WebSocket session given either an already-open WebSocket or a URL.\n *\n * @param webSocket Either the `wss://` URL to connect to, or an already-open WebSocket object to\n * use.\n * @param localMain The main RPC interface to expose to the peer. Returns a stub for the main\n * interface exposed from the peer.\n */\nexport let newWebSocketRpcSession:<T extends RpcCompatible<T> = Empty>\n    (webSocket: WebSocket | string, localMain?: any, options?: RpcSessionOptions) => RpcStub<T> =\n    <any>newWebSocketRpcSessionImpl;\n\n/**\n * Initiate an HTTP batch session from the client side.\n *\n * The parameters to this method have exactly the same signature as `fetch()`, but the return\n * value is an RpcStub. You can customize anything about the request except for the method\n * (it will always be set to POST) and the body (which the RPC system will fill in).\n */\nexport let newHttpBatchRpcSession:<T extends RpcCompatible<T>>\n    (urlOrRequest: string | Request, options?: RpcSessionOptions) => RpcStub<T> =\n    <any>newHttpBatchRpcSessionImpl;\n\n/**\n * Initiate an RPC session over a MessagePort, which is particularly useful for communicating\n * between an iframe and its parent frame in a browser context. Each side should call this function\n * on its own end of the MessageChannel.\n */\nexport let newMessagePortRpcSession:<T extends RpcCompatible<T> = Empty>\n    (port: MessagePort, localMain?: any, options?: RpcSessionOptions) => RpcStub<T> =\n    <any>newMessagePortRpcSessionImpl;\n\n/**\n * Implements unified handling of HTTP-batch and WebSocket responses for the Cloudflare Workers\n * Runtime.\n *\n * SECURITY WARNING: This function accepts cross-origin requests. If you do not want this, you\n * should validate the `Origin` header before calling this, or use `newHttpBatchRpcSession()` and\n * `newWebSocketRpcSession()` directly with appropriate security measures for each type of request.\n * But if your API uses in-band authorization (i.e. it has an RPC method that takes the user's\n * credentials as parameters and returns the authorized API), then cross-origin requests should\n * be safe.\n */\nexport async function newWorkersRpcResponse(request: Request, localMain: any) {\n  if (request.method === \"POST\") {\n    let response = await newHttpBatchRpcResponse(request, localMain);\n    // Since we're exposing the same API over WebSocket, too, and WebSocket always allows\n    // cross-origin requests, the API necessarily must be safe for cross-origin use (e.g. because\n    // it uses in-band authorization, as recommended in the readme). So, we might as well allow\n    // batch requests to be made cross-origin as well.\n    response.headers.set(\"Access-Control-Allow-Origin\", \"*\");\n    return response;\n  } else if (request.headers.get(\"Upgrade\")?.toLowerCase() === \"websocket\") {\n    return newWorkersWebSocketRpcResponse(request, localMain);\n  } else {\n    return new Response(\"This endpoint only accepts POST or WebSocket requests.\", { status: 400 });\n  }\n}\n"]}
// Generated by purs version 0.15.15
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Apply from "../Control.Apply/index.js";
import * as Control_Monad_Rec_Class from "../Control.Monad.Rec.Class/index.js";
import * as Control_Monad_Trans_Class from "../Control.Monad.Trans.Class/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Monoid from "../Data.Monoid/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as Effect_Class from "../Effect.Class/index.js";
var $runtime_lazy = function (name, moduleName, init) {
    var state = 0;
    var val;
    return function (lineNumber) {
        if (state === 2) return val;
        if (state === 1) throw new ReferenceError(name + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
        state = 1;
        val = init();
        state = 2;
        return val;
    };
};
var map = /* #__PURE__ */ Data_Functor.map(Data_Tuple.functorTuple);
var More = /* #__PURE__ */ (function () {
    function More(value0) {
        this.value0 = value0;
    };
    More.create = function (value0) {
        return new More(value0);
    };
    return More;
})();
var Lift = /* #__PURE__ */ (function () {
    function Lift(value0) {
        this.value0 = value0;
    };
    Lift.create = function (value0) {
        return new Lift(value0);
    };
    return Lift;
})();
var Stop = /* #__PURE__ */ (function () {
    function Stop(value0, value1, value2) {
        this.value0 = value0;
        this.value1 = value1;
        this.value2 = value2;
    };
    Stop.create = function (value0) {
        return function (value1) {
            return function (value2) {
                return new Stop(value0, value1, value2);
            };
        };
    };
    return Stop;
})();
var RWSET = function (x) {
    return x;
};
var monadTransRWSET = function (dictMonoid) {
    var mempty = Data_Monoid.mempty(dictMonoid);
    return {
        lift: function (dictMonad) {
            var map1 = Data_Functor.map(((dictMonad.Bind1()).Apply0()).Functor0());
            return function (m) {
                return function (v, state, v1, lift$prime, v2, done) {
                    return lift$prime(map1(function (a) {
                        return function (v3) {
                            return done(state, a, mempty);
                        };
                    })(m));
                };
            };
        }
    };
};
var lazyRWSET = function (dictMonoid) {
    return {
        defer: function (f) {
            return function (environment, state0, more, lift$prime, error, done) {
                var v = f(Data_Unit.unit);
                return v(environment, state0, more, lift$prime, error, done);
            };
        }
    };
};
var functorRWSET = {
    map: function (f) {
        return function (v) {
            return function (environment, state0, more, lift$prime, error, done) {
                return more(function (v1) {
                    return v(environment, state0, more, lift$prime, error, function (state1, a, w) {
                        return more(function (v2) {
                            return done(state1, f(a), w);
                        });
                    });
                });
            };
        };
    }
};
var applyRWSET = function (dictMonoid) {
    var append = Data_Semigroup.append(dictMonoid.Semigroup0());
    return {
        apply: function (v) {
            return function (v1) {
                return function (environment, state0, more, lift$prime, error, done) {
                    return more(function (v2) {
                        return v(environment, state0, more, lift$prime, error, function (state1, f, w0) {
                            return more(function (v3) {
                                return v1(environment, state1, more, lift$prime, error, function (state2, a, w1) {
                                    return more(function (v4) {
                                        return done(state2, f(a), append(w0)(w1));
                                    });
                                });
                            });
                        });
                    });
                };
            };
        },
        Functor0: function () {
            return functorRWSET;
        }
    };
};
var bindRWSET = function (dictMonoid) {
    var append = Data_Semigroup.append(dictMonoid.Semigroup0());
    var applyRWSET1 = applyRWSET(dictMonoid);
    return {
        bind: function (v) {
            return function (f) {
                return function (environment, state0, more, lift$prime, error, done) {
                    return more(function (v1) {
                        return v(environment, state0, more, lift$prime, error, function (state1, x, w0) {
                            return more(function (v2) {
                                var v3 = f(x);
                                return v3(environment, state1, more, lift$prime, error, function (state2, y, w1) {
                                    return more(function (v4) {
                                        return done(state2, y, append(w0)(w1));
                                    });
                                });
                            });
                        });
                    });
                };
            };
        },
        Apply0: function () {
            return applyRWSET1;
        }
    };
};
var semigroupRWSET = function (dictMonoid) {
    var lift2 = Control_Apply.lift2(applyRWSET(dictMonoid));
    return function (dictSemigroup) {
        return {
            append: lift2(Data_Semigroup.append(dictSemigroup))
        };
    };
};
var applicativeRWSET = function (dictMonoid) {
    var mempty = Data_Monoid.mempty(dictMonoid);
    var applyRWSET1 = applyRWSET(dictMonoid);
    return {
        pure: function (a) {
            return function (v, state, v1, v2, v3, done) {
                return done(state, a, mempty);
            };
        },
        Apply0: function () {
            return applyRWSET1;
        }
    };
};
var monadRWSET = function (dictMonoid) {
    var applicativeRWSET1 = applicativeRWSET(dictMonoid);
    var bindRWSET1 = bindRWSET(dictMonoid);
    return {
        Applicative0: function () {
            return applicativeRWSET1;
        },
        Bind1: function () {
            return bindRWSET1;
        }
    };
};
var monadAskRWSET = function (dictMonoid) {
    var mempty = Data_Monoid.mempty(dictMonoid);
    var monadRWSET1 = monadRWSET(dictMonoid);
    return {
        ask: function (environment, state, v, v1, v2, done) {
            return done(state, environment, mempty);
        },
        Monad0: function () {
            return monadRWSET1;
        }
    };
};
var monadReaderRWSET = function (dictMonoid) {
    var monadAskRWSET1 = monadAskRWSET(dictMonoid);
    return {
        local: function (f) {
            return function (v) {
                return function (environment, state0, more, lift$prime, error, done) {
                    return more(function (v1) {
                        return v(f(environment), state0, more, lift$prime, error, function (state1, a, w) {
                            return more(function (v2) {
                                return done(state1, a, w);
                            });
                        });
                    });
                };
            };
        },
        MonadAsk0: function () {
            return monadAskRWSET1;
        }
    };
};
var monadEffectRWSET = function (dictMonoid) {
    var lift = Control_Monad_Trans_Class.lift(monadTransRWSET(dictMonoid));
    var monadRWSET1 = monadRWSET(dictMonoid);
    return function (dictMonadEffect) {
        return {
            liftEffect: (function () {
                var $258 = lift(dictMonadEffect.Monad0());
                var $259 = Effect_Class.liftEffect(dictMonadEffect);
                return function ($260) {
                    return $258($259($260));
                };
            })(),
            Monad0: function () {
                return monadRWSET1;
            }
        };
    };
};
var monadRecRWSET = function (dictMonoid) {
    var append = Data_Semigroup.append(dictMonoid.Semigroup0());
    var mempty = Data_Monoid.mempty(dictMonoid);
    var monadRWSET1 = monadRWSET(dictMonoid);
    return {
        tailRecM: function (f) {
            return function (a0) {
                return function (environment, state0, more, lift, error, done) {
                    var $lazy_loop = $runtime_lazy("loop", "Uncurried.RWSET", function () {
                        return function (state1, a1, w1) {
                            return function (gas) {
                                var v = f(a1);
                                return v(environment, state1, more, lift, error, function (state2, s, w2) {
                                    if (s instanceof Control_Monad_Rec_Class.Loop) {
                                        var $210 = gas === 0;
                                        if ($210) {
                                            return more(function (v1) {
                                                return $lazy_loop(161)(state2, s.value0, append(w1)(w2))(30);
                                            });
                                        };
                                        return $lazy_loop(163)(state2, s.value0, append(w1)(w2))(gas - 1 | 0);
                                    };
                                    if (s instanceof Control_Monad_Rec_Class.Done) {
                                        return done(state2, s.value0, append(w1)(w2));
                                    };
                                    throw new Error("Failed pattern match at Uncurried.RWSET (line 157, column 23 - line 165, column 58): " + [ s.constructor.name ]);
                                });
                            };
                        };
                    });
                    var loop = $lazy_loop(152);
                    return loop(state0, a0, mempty)(30);
                };
            };
        },
        Monad0: function () {
            return monadRWSET1;
        }
    };
};
var monadStateRWSET = function (dictMonoid) {
    var mempty = Data_Monoid.mempty(dictMonoid);
    var monadRWSET1 = monadRWSET(dictMonoid);
    return {
        state: function (f) {
            return function (v, state0, v1, v2, v3, done) {
                var v4 = f(state0);
                return done(v4.value1, v4.value0, mempty);
            };
        },
        Monad0: function () {
            return monadRWSET1;
        }
    };
};
var monadTellRWSET = function (dictMonoid) {
    var Semigroup0 = dictMonoid.Semigroup0();
    var monadRWSET1 = monadRWSET(dictMonoid);
    return {
        tell: function (w) {
            return function (v, state, v1, v2, v3, done) {
                return done(state, Data_Unit.unit, w);
            };
        },
        Semigroup0: function () {
            return Semigroup0;
        },
        Monad1: function () {
            return monadRWSET1;
        }
    };
};
var monadWriterRWSET = function (dictMonoid) {
    var monadTellRWSET1 = monadTellRWSET(dictMonoid);
    return {
        listen: function (v) {
            return function (environment, state0, more, lift$prime, error, done) {
                return more(function (v1) {
                    return v(environment, state0, more, lift$prime, error, function (state1, a, w) {
                        return more(function (v2) {
                            return done(state1, new Data_Tuple.Tuple(a, w), w);
                        });
                    });
                });
            };
        },
        pass: function (v) {
            return function (environment, state0, more, lift$prime, error, done) {
                return more(function (v1) {
                    return v(environment, state0, more, lift$prime, error, function (state1, v2, w) {
                        return more(function (v3) {
                            return done(state1, v2.value0, v2.value1(w));
                        });
                    });
                });
            };
        },
        Monoid0: function () {
            return dictMonoid;
        },
        MonadTell1: function () {
            return monadTellRWSET1;
        }
    };
};
var monadThrowRWSET = function (dictMonoid) {
    var mempty = Data_Monoid.mempty(dictMonoid);
    var monadRWSET1 = monadRWSET(dictMonoid);
    return {
        throwError: function (e) {
            return function (v, state, v1, v2, error, v3) {
                return error(state, e, mempty);
            };
        },
        Monad0: function () {
            return monadRWSET1;
        }
    };
};
var monadErrorRWSET = function (dictMonoid) {
    var append = Data_Semigroup.append(dictMonoid.Semigroup0());
    var monadThrowRWSET1 = monadThrowRWSET(dictMonoid);
    return {
        catchError: function (v) {
            return function (f) {
                return function (environment, state0, more, lift$prime, error, done) {
                    return more(function (v1) {
                        return v(environment, state0, more, lift$prime, function (state1, e, w0) {
                            return more(function (v2) {
                                var v3 = f(e);
                                return v3(environment, state1, more, lift$prime, error, function (state2, b, w1) {
                                    return done(state2, b, append(w0)(w1));
                                });
                            });
                        }, done);
                    });
                };
            };
        },
        MonadThrow0: function () {
            return monadThrowRWSET1;
        }
    };
};
var monoidRWSET = function (dictMonoid) {
    var pure = Control_Applicative.pure(applicativeRWSET(dictMonoid));
    var semigroupRWSET1 = semigroupRWSET(dictMonoid);
    return function (dictMonoid1) {
        var semigroupRWSET2 = semigroupRWSET1(dictMonoid1.Semigroup0());
        return {
            mempty: pure(Data_Monoid.mempty(dictMonoid1)),
            Semigroup0: function () {
                return semigroupRWSET2;
            }
        };
    };
};
var altRWSET = function (dictMonoid) {
    return {
        alt: function (v) {
            return function (v1) {
                return function (environment, state0, more, lift, error, done) {
                    return more(function (v2) {
                        return v(environment, state0, more, lift, function (state1, v3, v4) {
                            return more(function (v5) {
                                return v1(environment, state1, more, lift, error, done);
                            });
                        }, done);
                    });
                };
            };
        },
        Functor0: function () {
            return functorRWSET;
        }
    };
};
var withRWSET = function (f) {
    return function (v) {
        return function (environment1, state1, more, lift$prime, error, done) {
            var v1 = f(environment1)(state1);
            return v(v1.value0, v1.value1, more, lift$prime, error, done);
        };
    };
};
var rwseT = function (dictFunctor) {
    var mapFlipped = Data_Functor.mapFlipped(dictFunctor);
    return function (dictMonoid) {
        return function (f) {
            return function (environment, state0, more, lift, error, done) {
                return more(function (v) {
                    return lift(mapFlipped(f(environment)(state0))(function (v1) {
                        return function (v2) {
                            if (v1.value1.value0 instanceof Data_Either.Left) {
                                return error(v1.value0, v1.value1.value0.value0, v1.value1.value1);
                            };
                            if (v1.value1.value0 instanceof Data_Either.Right) {
                                return done(v1.value0, v1.value1.value0.value0, v1.value1.value1);
                            };
                            throw new Error("Failed pattern match at Uncurried.RWSET (line 277, column 9 - line 281, column 30): " + [ v1.value1.value0.constructor.name ]);
                        };
                    }));
                });
            };
        };
    };
};
var runRWSET = function (dictMonadRec) {
    var Monad0 = dictMonadRec.Monad0();
    var map1 = Data_Functor.map(((Monad0.Bind1()).Apply0()).Functor0());
    var pure = Control_Applicative.pure(Monad0.Applicative0());
    var tailRecM = Control_Monad_Rec_Class.tailRecM(dictMonadRec);
    return function (r) {
        return function (s) {
            return function (v) {
                var go = function ($copy_step) {
                    var $tco_done = false;
                    var $tco_result;
                    function $tco_loop(step) {
                        var v1 = step(Data_Unit.unit);
                        if (v1 instanceof More) {
                            $copy_step = v1.value0;
                            return;
                        };
                        if (v1 instanceof Lift) {
                            $tco_done = true;
                            return map1(Control_Monad_Rec_Class.Loop.create)(v1.value0);
                        };
                        if (v1 instanceof Stop) {
                            $tco_done = true;
                            return pure(new Control_Monad_Rec_Class.Done(new Data_Tuple.Tuple(v1.value0, new Data_Tuple.Tuple(v1.value1, v1.value2))));
                        };
                        throw new Error("Failed pattern match at Uncurried.RWSET (line 252, column 15 - line 258, column 35): " + [ v1.constructor.name ]);
                    };
                    while (!$tco_done) {
                        $tco_result = $tco_loop($copy_step);
                    };
                    return $tco_result;
                };
                return tailRecM(go)(function (v1) {
                    return v(r, s, More.create, Lift.create, function (s$prime, e, w) {
                        return new Stop(s$prime, new Data_Either.Left(e), w);
                    }, function (s$prime, a, w) {
                        return new Stop(s$prime, new Data_Either.Right(a), w);
                    });
                });
            };
        };
    };
};
var mapRWSET = function (dictMonadRec) {
    var runRWSET1 = runRWSET(dictMonadRec);
    return function (dictFunctor) {
        var mapFlipped = Data_Functor.mapFlipped(dictFunctor);
        return function (f) {
            return function (k) {
                return function (environment, state, v, lift$prime, error, done) {
                    return lift$prime(mapFlipped(f(runRWSET1(environment)(state)(k)))(function (v1) {
                        return function (v2) {
                            if (v1.value1.value0 instanceof Data_Either.Left) {
                                return error(v1.value0, v1.value1.value0.value0, v1.value1.value1);
                            };
                            if (v1.value1.value0 instanceof Data_Either.Right) {
                                return done(v1.value0, v1.value1.value0.value0, v1.value1.value1);
                            };
                            throw new Error("Failed pattern match at Uncurried.RWSET (line 322, column 9 - line 326, column 30): " + [ v1.value1.value0.constructor.name ]);
                        };
                    }));
                };
            };
        };
    };
};
var hoistRWSET = function (f) {
    return function (v) {
        return function (environment, state, more, lift$prime, error, done) {
            return v(environment, state, more, function ($261) {
                return lift$prime(f($261));
            }, error, done);
        };
    };
};
var execRWSET = function (dictMonadRec) {
    var map1 = Data_Functor.map((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0());
    var runRWSET1 = runRWSET(dictMonadRec);
    return function (r) {
        return function (s) {
            return function (k) {
                return map1(map(Data_Tuple.snd))(runRWSET1(r)(s)(k));
            };
        };
    };
};
var evalRWSET = function (dictMonadRec) {
    var map1 = Data_Functor.map((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0());
    var runRWSET1 = runRWSET(dictMonadRec);
    return function (r) {
        return function (s) {
            return function (k) {
                return map1(Data_Tuple.snd)(runRWSET1(r)(s)(k));
            };
        };
    };
};
export {
    RWSET,
    rwseT,
    runRWSET,
    evalRWSET,
    execRWSET,
    hoistRWSET,
    mapRWSET,
    withRWSET,
    functorRWSET,
    applyRWSET,
    applicativeRWSET,
    altRWSET,
    bindRWSET,
    monadRWSET,
    monadAskRWSET,
    monadEffectRWSET,
    monadErrorRWSET,
    monadReaderRWSET,
    monadRecRWSET,
    monadStateRWSET,
    monadTellRWSET,
    monadThrowRWSET,
    monadTransRWSET,
    monadWriterRWSET,
    semigroupRWSET,
    monoidRWSET,
    lazyRWSET
};
//# sourceMappingURL=index.js.map
